# os内存管理

## 1.为什么要有逻辑地址（虚拟地址）

- 逻辑内存也叫虚拟内存。
- 程序无法知道可用的物理地址，所以必须做出映射。

## 2.虚拟地址与物理地址如何映射

- 虚拟内存是页
- 物理内存是页帧
  - ![image-20210124164239958](http://pichost.yangyadong.site/img/image-20210124164239958.png)
- 页表记录了映射关系，以及记录了当前这一条目是否可用、当前这一页的读写权限、当前这个帧是否是脏的一个帧等。
  - ![image-20210124164444295](http://pichost.yangyadong.site/img/image-20210124164444295.png)
- 每个进程独立维护一个页表。
  - ![image-20210124164729575](http://pichost.yangyadong.site/img/image-20210124164729575.png)

## 3.小知识

- 1.内存的一个地址里面“住”的是一个字节byte的数据
- 2.32位的操作系统物理地址有2^32次方个，即4G个，因而只能使用4GByte容量的内存
- 3.任何一个32位的程序可操作的虚拟地址是2^32个，即任何一个32位程序都可以使用4GByte的内存容量
- 4.上面势必造成多个程序使用内存总和大于物理内存，此时会借助硬盘，将并不着急使用的内存先放到硬盘，page table对应的帧号显示的是硬盘。

## 4.看一次内存映射的过程

### 前提

- 机器：32位的系统，256MByte物理内存（`2^8*2^20=2^28`即28bit的地址序号），页大小为4KB
- 程序：32位程序
- 4K即`2^2*2^10=2^12`，需要12bit来表示4K个地址序号。
  - 虚拟地址（32位程序即4G个地址）：32bit=20bit页号+12bit页内偏移
    - 即`1M页*每一页4K个地址=4G个地址`。每一个地址对应1Byte内容，所以总容量4GByte
  - 物理地址（因为只有256M个地址）：28bit=16bit页号+12bit页内偏移
    - 即`64K页*每一页4K个地址=256M个地址`。每一个地址对应1Byte内容，所以总容量256MByte

### 举例

- 对于一个地址0x000011a3
  - 页号（20bit）：00001
  - 页内偏移（12bit）：1a3
- ![image-20210124174807483](http://pichost.yangyadong.site/img/image-20210124174807483.png)
- 思考：如果对应的帧号是磁盘，会发生什么？
  - 会触发缺页异常。触发程序进入内核态，内核找到磁盘中这一帧对应的数据，把它从磁盘加载到内存空闲页处，然后把加载好的内存这一帧的帧号填写到页表中。然后重新进行一个寻址的过程。
  - 如果内存没有空闲，操作系统会把不常用的帧从内存逐出到磁盘（内存置换算法），所以linux下那个磁盘部分叫做swap分区。然后就有空闲页了。

## 5.分页小结

- 1.分页使得每个程序都有很大的虚拟地址空间，通过映射磁盘和高效的置换算法，使得内存“无限大”。
- 2.分页使不同的进程的内存隔离，保证了安全。
- 3.分页降低了内存碎片问题
- 4.但是上述分页过程中，需要两次读内存，时间上有待优化；另一个方面，页表占用空间较大，空间上也有待优化。
  - 因为**页表是存放在物理内存中的**。所以需要两次读内存，第一次需要在物理内存读页表拿对应帧号，第二次拿到帧号再去查物理内存上的数据。

## 6.优化

### 时间优化

- 将最常访问的几个(一般8-128个左右)页表项存到访问速度更快的硬件中，一般是在MMU(内存管理单元，集成在CPU中)，这个小表的名称为TLB (Translation Lookaside Buffer)，可以称其为快表。
  - 页表在物理内存中。快表在CPU上。
- 寻址时先查快表TLB，如果miss（未命中）后再查page table。快表命中率很高，因为一个事实：一个程序最常访问的页没几个。

### 空间优化

- 多级页表
  - 多级页表可以缩小页表占用的空间

## 7.程序内部的内存管理-分段

### 虚拟地址只是逻辑上分段（也就是方便程序员使用），实际上还是记录的页表，即虚拟内存每一页与物理内存每一页帧的对应关系。也就是说实际上是纯分页模式，虚拟内存也不是分段的。

![image-20210124202025975](http://pichost.yangyadong.site/img/image-20210124202025975.png)

- libraries段
  - 函数库的区域。比如linux中so文件，windows的dll动态链接库，都是加载到这儿的。
  - malloc若申请>128K的内存会调用mmap，在堆和栈之间区域申请内存。和这里的libararies区其实是相同位置的，因为它们都是页 映射磁盘（mmap就是文件映射内存的系统调用）
    - mmap不仅有申请内存的作用，还有实现文件映射的作用，可以减少用户空间和内核空间之间内存的拷贝。
  - 进程可以共享libraries区，这也是进程间通信的共享内存的方式。
    - 共享内存极其常见，例如windows下选择文件的那个对话框。
    - ![image-20210124202528330](http://pichost.yangyadong.site/img/image-20210124202528330.png)

### 分段和分页结合的方式（现代都不是结合，而是纯分页。所谓虚拟内存分段，只是方便程序员使用，在系统层次上虚拟内存和物理内存都是分页的。）

- 分段和分页结合的方式是：
  - 每个段有很多页，页表中存储段号和页号唯一映射物理帧号。
- 但是段页结合的模式只在x86 Intel cpu等少数cpu上还支持，更新的x86-64架构都不再支持段页结合了。但是**仍然保留了段的概念，只是程序层面便于运算，并不会影响分页式内存管理了。**
- **换句话说，现代的CPU，虚拟内存其实也是分页的。分段只是方便程序员使用，而实际上（在系统层面上）是纯分页的模式。虚拟地址只是逻辑上分段，实际上还是记录的页表，即虚拟内存每一页与物理内存每一页帧的对应关系。**
- ![image-20210124203420325](http://pichost.yangyadong.site/img/image-20210124203420325.png)
- 不同进程之间，只有kernel Space一定是共享的。然后有可能有一部分libraries是共享的。
  - 所以dll编译后并不会打包在程序里。但是lib文件会打包在程序里。
- 堆、栈、数据区、文本区一定都不是共享的。各自占各自的

## 8.CPU缓存cache如何起作用？

- 三级缓存。
  - 原子性和可见性。

# 从上到下看内存

## 1.内存条、总线、DMA

- CPU与内存条之间有**地址总线**和**数据总线**
- 总线除此之外，还有IO总线、控制总线。
- IO总线比如：USB（通用串行总线）、PCIE总线（直接跟CPU相连，比如显卡就是利用这个PCIE总线跟CPU交互）
- ![image-20210125153741197](http://pichost.yangyadong.site/img/image-20210125153741197.png)
  - 南桥用来接外设，除此之外还有DMA控制器（DMAC）。
- DMA控制器（DMAC），中文名叫直接内存访问控制器，Direct Memory Access Controler
- CPU不会去做读取硬盘文件这种机械性的活儿，而是交给DMAC去做。DMAC替CPU把文件从硬盘读取到内存中。
  - ![image-20210125155217734](http://pichost.yangyadong.site/img/image-20210125155217734.png)
  - 首先需要知道，主板上有两个芯片，一个是CPU，另一个是DMAC
  - CPU可以访问内存，是因为有地址总线和数据总线跟内存相连。DMAC是凭什么直接访问内存呢？
    - 答：是因为CPU把活儿交给DMAC的时候，下一步就把总线的控制权完全交给DMAC，这时候CPU就不能控制总线了。所以DMAC拿到了总线控制权，就可以进行内存的数据访问和数据读写了。
  - 那么接着思考，如果读一个特别大的文件到内存，应该要读很久，那么DMAC一直掌握了所有总线控制权，因为DMAC完成文件读取需要把硬盘上数据搬运到内存中。那么CPU这期间理论上，CPU没有总线控制权，就跟断开了总线一样，那么CPU是不可能收到外设的消息的，比如说我们的鼠标按说就应该失灵了。但是实际上并不是，为什么？
    - 答：因为DMA在进行文件的读取的过程中，并不是一直持续的掌握着总线的控制权，而是跟CPU分时轮换接管这个总线控制权。CPU拿到总线控制权是去做别的任务的，而DMA就是替CPU打工的，完成之前CPU分配给它的任务。
    - 比如CPU跟DMA商量好，一人占用总线控制权1ms来回轮换，这对用户是无感知的。
- 经典题目：
  - 1.DMA控制器和CPU可以同时使用总线吗？
    - 答案：不可以。总线的控制是分时轮换的。总线同一时刻只能被一方使用。
  - 2.在DMA方式下，CPU与总线的关系是：
    - 答案：隔离状态。DMA在控制总线的时候，CPU跟总线的关系就跟断开连接了一样。

## 2.操作系统的内存管理与内存分类

- 进程看到的地址是虚拟内存。
- 虚拟内存与物理内存的映射表叫做页表。
- 每个进程都有一个单独的页表，每个32位进程也都有4G的可用虚拟内存。
- 很多进程同时运行时，物理内存肯定是不够用，这时不常用的内存会被放置在硬盘上，即页表映射会是虚拟内存到硬盘，而不再是虚拟内存到物理内存。
- LINUX下内存
  - ![image-20210125161929573](http://pichost.yangyadong.site/img/image-20210125161929573.png)
  - used：包含shared
  - free：真正的空闲，没有任何东西在使用。
  - shared：内存共享区
  - buff/cache：我们读过的文件，会暂时帮我们缓存在这个地方。如果下次再读这些已经读过的文件，就可以直接在内存中拿出来，加速对文件的读写操作。
    - 它只是尽量去缓存，如果其他进程需要内存了，它就把缓存释放了，把空间给别人来用。
  - available：这才是真正的剩余可用内存。而不是free。
- windows下内存
  - ![image-20210125163611900](http://pichost.yangyadong.site/img/image-20210125163611900.png)

## 3.内存相关的系统调用

### 简述

- 系统调用是用户态切内核态的方式之一，申请内存就需要使用系统调用
  - 用户态切内核态的方式除此之外，还有中断和异常
  - 简言之：用户没法直接操作硬件，比如内存。必须交给内核去操作，内核操作完了再给我们结果。
- ![image-20210125164348699](http://pichost.yangyadong.site/img/image-20210125164348699.png)

### brk系统调用

- brk系统调用
  - 它其实是在不断地提升heap的上界。
  - ![image-20210125164621570](http://pichost.yangyadong.site/img/image-20210125164621570.png)
    - 可以看到，brk申请的内存都是连续的。它就是在抬高heap的上界
  - ![image-20210125164645921](http://pichost.yangyadong.site/img/image-20210125164645921.png)
    - 思考，为什么我只申请了1个字节内存，我却能操作其它的内存？
    - 仔细读代码，我申请了1个字节内存，我却转成了int*类型。那first+1就指向了第5个字节位置，因为int占4个字节。
    - 原因：你虽然只申请了1个字节，但是因为操作系统对内存管理的最小单位是一页。即4KByte。看似你只申请了1Byte，其实OS准备了一页即4KByte给你用。所以第5到第8字节那些空间是在这一页里的，操作系统允许该进程支配这一页的内存。
  - ![image-20210125165225483](http://pichost.yangyadong.site/img/image-20210125165225483.png)
    - first+1024就是第4097字节了，跨够了一页，OS立马给你报段错误。因为OS只给了你一页，你操作超过一页了，OS并没有分配给你第二页可用。
    - Segmentation fault即代表你操作内存越界了。

### mmap系统调用

- mmap一个作用是分配超过128K的内存空间。
- mmap另一个作用是将文件映射到内存。（就是把文件从硬盘读到内存）
  - ![image-20210125170249177](http://pichost.yangyadong.site/img/image-20210125170249177.png)
  - fd设置成-1，即用mmap分配内存的意思。
  - fd设置成正常值，即用mmap将文件映射到内存
- 例子1：演示mmap分配内存
  - ![image-20210125170608185](http://pichost.yangyadong.site/img/image-20210125170608185.png)
  - ![image-20210125170614968](http://pichost.yangyadong.site/img/image-20210125170614968.png)
  - 可以看到只有100次小错误，minflt。因为OS是惰性的，进程需要分配内存100页即100*4096Byte可以，但是你不用OS先不给你。你每次真的要操作这一页内容时候，触发小错误minflt，OS为进程分配物理内存，并把虚拟内存对应到物理内存上。
- 例子2：演示mmap将磁盘文件映射到内存中，模拟读文件的操作
  - ![image-20210125171033179](http://pichost.yangyadong.site/img/image-20210125171033179.png)
  - ![image-20210125171039450](http://pichost.yangyadong.site/img/image-20210125171039450.png)
  - 可以看到，触发了一次majorfault大错误。
  - 原因：
    - 这个将文件映射到内存这一操作也是惰性的。mmap跟操作系统说要映射，OS说可以，但是OS先不做这事。等你真的需要在内存读这个资源的时候，OS才触发一个大错误，把文件从内存读进来。
    - 所以当第一次真的要读那个文件内容时（即print("%c“，file_in_memory[i])那行），一去读内存，发现对应的是磁盘，会触发大错误majorfault，OS这时才把文件从磁盘读到内存中。
    - 剩余的小错误是要把虚拟内存对应到物理内存上。
  - 思考，使用mmap和使用普通的fread、read系统调用等，有什么区别。
    - fread的操作流程是：read系统调用进入内核态，内核态进行文件读取，将文件的内容加载到内核空间，然后内核空间复制拷贝到用户空间，然后从内核态切换回用户态，然后用户的程序就可以读到文件的内容了。
    - mmap是直接把文件进行了一个映射到内存，一开始是惰性的，即页表中填充的其实还是磁盘。等到真正要读取的时候，就会触发缺页，把文件加载到内存中。不过有个不同的地方是，有可能该文件有一部分被内核空间映射过，mmap可直接使用那些重复的内容。即这种说法，mmap创造了这样一种内存，这一段内存是用户空间和内核空间共享的内存。所以这里的共享内存不是指那个进程间通信的共享内存区，而是指内核空间和用户空间在映射同一段物理内存罢了。
      - ![image-20210125172517838](http://pichost.yangyadong.site/img/image-20210125172517838.png)
  - mmap一般而言，映射的空间是Stack和heap之间的区域。它相比read系统调用，避免了内核空间到用户空间（用户空间即堆、栈、数据区等等的那些）的拷贝。所以mmap是实现0拷贝的一种技术。
  - 思考，mmap这么牛，还要read系统调用干嘛？
    - mmap的最大优点是避免的read系统调用从内核空间到用户空间的拷贝。
    - 但是mmap的缺点是，mmap无法利用buffer/cache，对文件缓存的那个物理内存空间。
    - 再一个缺点，mmap第一次触发的缺页异常（因为mmap映射完，OS是惰性的，你不访问OS就不加载），这个缺页异常跟read函数所浪费的时间相比不一定孰优孰劣。

