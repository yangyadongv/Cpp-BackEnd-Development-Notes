## 2021.6.17 vivo提前批

- 1.幸运员工抽奖：从团队中选出整个工号中含有数字7或者工号是7的倍数的员工
  - 暴力字符串
- 2.货运装箱问题
  - 01背包
- 3.最短路径
  - 图：dfs、拓扑排序？杂糅题目，不会

## 2021.6.19 同花顺提前批

- 各种杂七杂八的选择、简答、编程。
- 原地修改数组：leetcode283.移动零
  - 快慢指针、双指针

## 2021.6.21 tplink提前批

- 1.判断链表环的入口
  - 快慢指针
- 2.两个有序数组找中位数
  - 递归形式的二分查找（将题目变形为找两个有序数组的第K大元素）

## 2022.6.29 乐鑫科技提前批

- 1.比较简单

  - 题目复杂，实际上就是个sort排序，然后去前三

- 2.最大上升子序列：dp问题

  - 把第一维进行排序（类似信封问题），排完序后，所有满足不交叉航线的可行解的第二维一定是一个上升子序列

  - 问题转化成求解收益最大的上升子序列

  - ```c++
    int main() {
        int size=5;
        vector <vector<int >> data{     
            //北岸坐标，南岸坐标，吞吐量
             {2,5,3},
             {1,4,2},
             {4,2,2},
             {3,1,1},
             {5,3,1}
        };
    
        sort(data.begin(), data.end(),[](vector<int> a, vector<int> b) {return a[0] < b[0]; });//按照第一维进行升序排列
       /*    {1,4,2},  
             {2,5,3},
             {3,1,1},
             {4,2,2},
             {5,3,1}
        */
    
        vector<int> dp(size,0);//最长升序子序列的模板
        dp[0] = data[0][2];
        for (int i = 1; i < size; i++) {
            int maxVal = 0;
            for (int j = 0; j < i; j++) {
                if (data[j][1] < data[i][1])
                    maxVal = max(maxVal, dp[j]);
            }
            dp[i] = maxVal + data[i][2];
        }
        
        int res = 0;
        for (int i : dp) {
            res = max(i, res);
        }
        cout << res << endl;
    
    	return 0;
    }
    ```

    
