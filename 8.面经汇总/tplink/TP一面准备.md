# TP一面准备

## 1、虚函数

虚函数实现动态多态，程序运行时实现动态绑定，对象中的虚函数vptr决定真正调用的是哪个函数。

虚函数的实现：**虚函数指针和虚函数表。**

虚函数指针：虚函数指针 (virtual function pointer) 从本质上来说就只是一个指向函数的指针，与普通的指针并无区别。它指向用户所定义的虚函数，具体是在子类里的实现，当子类调用虚函数的时候，实际上是通过调用该虚函数指针从而找到接口。

虚函数表：每当创建一个包有虚函数的类或从包有虚函数的类派生一个类时，编译器为这个类创建一个虚函数表vtable，该虚函数表将被该类的所有对象共享。在这个表中，编译器放置了在这个类中或在它的基类中所有已声明为virtual的函数的地址，实际的虚函数在代码段。

## 2、多态

多态的实现主要分为静态多态和动态多态

+ 静态多态主要是重载（函数重载、运算符重载），在编译的时候就已经确定；
+ 动态多态时用虚函数机制实现的，编译时未确定，运行期间动态绑定。
  + 一个父类类型的指针指向一个子类对象的时候，使用父类的指针去调用子类重写的父类中的虚函数的时候，会调用子类重写过后的函数。

## 3、为什么要使用虚析构

在实现多态时，当用基类操作派生类，防止析构时只析构基类而不析构派生类的状况发生。

## 4、为什么C++默认的析构函数不是虚函数

虚函数需要额外的虚函数表和虚函数指针，占用额外的内存。对于不会被继承的类来说，其虚析构如果是虚函数，就会浪费内存，只有当需要当做父类时，设置为虚函数。

## 5、static关键字

+ 对于全局变量或普通函数，static限制其链接性，使其限制在本文件中使用。不必担心名称与其他文件中的全局变量、函数发生冲突；
+ 对于局部变量，static为其提供长久的寿命，每次进入作用域时提取旧值；
+ 对于类内静态成员函数，提供了该类型对象共用的一个数据；
+ 对于类内静态函数，不需要对象名，直接通过类名就可以直接调用类内静态函数成员

## 6、引用

引用变量是一个别名，它是某个已存在变量的另一个名字。

在函数调用的时候使用引用，可以减少参数传递。

## 7、构造函数和析构函数

类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称和类的名称是完全相同的并且不会返回任何类型，也不会返回void。构造函数可用于为某些成员变量设置初始值。

类的析构函数时类的一种特殊的成员函数，他在每次删除所创建对象时执行。析构函数的名称和类的名称是完全相同的，只是在前面加了个～，它不会返回任何值。析构函数在跳出程序前释放资源。

## 8、new和malloc

+ malloc和free为c的标准库函数，new和delete为C++的操作运算符；
+ malloc返回类型为void *，必须强制类型转换为对应类型指针，new则直接返回对应类型指针；
+ malloc开辟内存时返回内存地址要检查判空，开辟失败会返回NULL；new不用判断，内存分配失败会抛出异常
+ new/delete 底层基于malloc、free来实现
+ new分配的内存空间在堆，malloc分配的内存空间在自由存储区

## 9、内存

在C++中，内存分为五个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区

#### 1.堆

就是那些由new分配的内存块，他们的释放编译器不去管，由应用程序控制，一般一个new就要对应一个delete。如果程序员没有释放，那么在程序结束后，操作系统会自动回收。

#### 2.栈

在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

#### 3.自由存储区

由malloc分配的内存块，和堆相似，但是由free来结束他们的生命。

#### 4.全局/静态存储区

全局变量和静态变量分配的内存区域。

#### 5.常量存储区

这是一块比较特殊的存储区，他们里面存放的是常量，不允许被修改。

## 10、map和set的区别

map和set都是stl中的关联容器，map以键值对的形式存储，是一组映射关系，set只有值，可以认为只有一个数据，并且set中元素不可以重复。

## 11、如何避免内存泄漏

+ 用new申请动态内存之后，一定要用delete释放内存
+ 尽量使用动态指针，而不是手动地去管理内存
+ 尽量使用string代替char *

## 12、如何检测内存泄漏

使用_CrtDumpMemoryLeaks()自带宏

## 13、快排的基本思路及最坏时间复杂度

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分的值均比另一部分的值小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

最坏时间复杂度：待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，最坏时间复杂度为O(n2）。

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        if(n < 1)
            return {};
        quickSort(nums, 0, n - 1);
        return nums;
    }

    void quickSort(vector<int>& nums, int left, int right)
    {
        if(left >= right)
            return;
        
        int low = left, high = right;
        while(low < high)
        {
            while(low < high && nums[high] >= nums[left])
                high--;
            while(low < high && nums[low] <= nums[left])
                low++;
            swap(nums[high], nums[low]);
        }
        swap(nums[left], nums[low]);
        quickSort(nums, left, low - 1);
        quickSort(nums, low + 1, right);
    }
};
```

## 14、插入排序

将一个数插入一个已经排好序的有序表中，时间复杂度为O(n2）。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        for(int i = 1; i < n; i++)
            for(int j = 0; j < i; j++)
                if(nums[j] > nums[i])
                    swap(nums[j], nums[i]);
        
        return nums;
    }
};
```

## 15、冒泡排序

比较相邻的元素，如果前一个比后一个大，交换之。

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0; i < n - 1; i++)
            for(int j = 0; j < n - i - 1; j++)
                if(nums[j] > nums[j + 1])
                    swap(nums[j], nums[j + 1]);
        
        return nums;
    }
};
```

## 16、实现一个交换两个数值的宏

```c++
#define SWAP(x, y)
{
    x = x + y;
    y = x - y;
    x = x - y;
}
```

## 17、C++有哪些模板类

## 18、数组和链表的区别

![image-20210624222824007](C:\Users\o'l\AppData\Roaming\Typora\typora-user-images\image-20210624222824007.png)

# 计算机网络

## 1、为什么TCP挥手需要四次

在双方连接已建立后，此时需要客户端**主动发出关闭**信号

**1、第一次挥手：**

![第一次挥手](https://img-blog.csdnimg.cn/2021020610204186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

TCP客户进程会发送**TCP连接释放报文段**，并进入**终止等待1状态**


TCP连接释放报文段首部中有以下关键数据位：

+ **终止位FIN和确认位ACK**：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认
+ **序号seq字段**：值设置为u，u等于TCP客户进程之前**已传送过的数据的最后一个字节的序号加1**，用来表示发送过程中的最后一个字节序号为u。
+ **确认号ack字段**：值设置为v，v等于服务器进程之前**发送的数据中最后一个字节的序号加1**，也就是确认收到已经收到的服务器发送的数据

请注意：TCP规定**终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号**

**2、第二次挥手：**

![第二次挥手](https://img-blog.csdnimg.cn/20210206103509759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

接收方再接收到连接释放报文后，会发送一个普通的**TCP确认报文段**并且进入关闭等待状态。

普通的TCP确认报文段首部中有以下关键数据位：

+ **确认位ACK**：值被设置为1，表明这是一个普通的TCP确认报文段
+ **序号seq**：**值设置为v**，v等于TCP服务器进程之前**已传送过的数据的最后一个字节的序号加1**，与之前收到的TCP连接释放报文段中的确认号ack值匹配
+ 确认号ack字段：值为u+1，这是对TCP连接释放报文段的确认，也就是为发送方连接释放报文中的seq的值+1。

![img](https://img-blog.csdnimg.cn/20210206104044261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

在进行第二次挥手后，会产生以下过程：

TCP服务器进程通知高层应用进程，TCP客户进程要断开与自己的TCP连接，此时的**TCP连接进入半关闭状态**。所谓半关闭状态可以认为，此时**客户端与服务器的连接不再传输数据**，也就是客户端没有数据在发生。而此时**服务器若有剩余数据要发送会继续发送**。客户端到服务器这一信道关闭了，而服务器到客户端这一半没有关闭，因此称为半关闭状态。这个半关闭状态可能会持续一段时间，直到发送方没有数据进行发送。
在以上等待过程中，**客户端会进入终止等待2状态**：

![终止等待2状态](https://img-blog.csdnimg.cn/20210206104632136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

**3、此时当服务器没有数据要传输后，进行第三次挥手：**

![第三次挥手](https://img-blog.csdnimg.cn/2021020610480896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

此时TCP服务器进程会发送TCP连接释放报文段并进入最后确认状态。


在该报文段中有以下关键数据段：

+ **终止位FIN和确认位ACK**：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认。
+ **序号seq**：值为w，因为在半关闭状态下，TCP服务器进程可能又发送一段数据，因此w就是该段数据最后的序号。
+ **确认号ack**：值为u+1，这是对**之前收到的TCP连接释放报文段的重复确认**，因此值为发送方第一次挥手发送的seq值+1。

**4、第四次挥手：**

![第四次挥手](https://img-blog.csdnimg.cn/20210206105234687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

此时针对第三次挥手的报文段发送普通的TCP确认报文段，之后进入时间等待状态。


该报文段首部中有以下关键数据位：

+ **确认位ACK**：值被设置为1，表明这是一个普通的TCP确认报文段。  
+ **序号seq字段**：值设置为u+1，用来表示最后一个发送的字节序号，但是为何没有发送数据，而此时值要设置为u+1（对比第一次挥手数据），**因为TCP客户进程之前发送的TCP连接释放报文段(带有FIN)虽然不携带数据，但要消耗掉一个序号。**
+ **确认号ack**：值设置为w+1，这是对所收到的TCP连接释放报文段的确认

此时，**TCP服务器进程收到该报文段后就进入关闭状态**，而**TCP客户进程还要经过2MSL后才能进入关闭状态：**

![可独断经过2MSL后才能进入关闭状态](https://img-blog.csdnimg.cn/20210206105827639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

MSL具体的值可以根据TCP协议的不同实现进行设置。

## 2、TCP应用场景

当对网络通信质量有要求时，比如：整个数据要准确无误的传递给对方，这往往对于一些要求可靠的应用，比如HTTP,HTTPS,FTP等传输文件的协议，POP,SMTP等邮件的传输协议。常见使用TCP协议的应用：

+ 浏览器使用的：HTTP
+ FlashFXP:FTP
+ Outlook:POP，SMTP
+ QQ文件传输

## 3、UDP应用场景

对当前网络通讯质量要求不高的时候，要求网络通讯速度尽量的快，这时就使用UDP
日常生活中常见使用UDP协议：

+ QQ语音
+ QQ视频
+ DNS

## 4、计算机网络五层协议

物理层、数据链路层、网络层、传输层、应用层

## 5、OSI七层协议

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

## 6、TCP和UDP的区别



- 1.连接
  - UDP是无连接的
  - TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接
- 2.服务对象
  - UDP支持一对一，一对多，多对一，多对多的交互通信
  - TCP是点到点的两点间服务，即一条TCP连接只能有两个端点
- 3.可靠性
  - UDP是尽最大努力交付，不保证可靠交付
  - TCP是可靠交付：无差错、不丢失、不重复，按序到达
- 4.流量控制、拥塞控制
  - UDP没有拥塞控制，流量控制，网络拥塞不会影响源主机的发送效率
  - TCP有流量控制，来协调两台计算机之间的通信速率。TCP有拥塞控制，协调网络中所有使用TCP协议的设备，避免出现网络拥塞
- 5.首部长度
  - UDP首部长度固定，8字节
  - TCP首部长度20-60字节，包含20字节固定长度，选项长度可变0-40字节
- 6.数据部分长度
  - UDP面向报文，UDP对应用层交下来的报文，既不合并，也不拆分，保留这些报文的边界
    - 若应用层报文太长，数据包长度超过了MTU，那UDP交给IP层后，IP层传给链路层时会进行分片
  - TCP面向字节流，最大报文段长度MSS是建立时协商的(即最大多少byte一组，或者说叫一段，一个报文段)。具体到多少字节为一组，由三种机制控制。因此TCP的数据报文段的长度不确定，但最大不超过MSS
    - 1.缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去
    - 2.发送方的应用程序指明要求发送报文段，即TCP支持的push操作
    - 3.发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段(不能超过MSS)发送出去

## 7、三次握手

**1、第一次发送握手报文：**

![第一次发送握手报文](https://img-blog.csdnimg.cn/202102052321410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

在打算建立TCP连接时，客户端向TCP服务器进程发送**TCP连接请求报文段**，并进入同步已发送状态


TCP连接请求报文段首部中，有两个关键数据：

+ 同步位SYN：被设置为1，表明这是一个TCP连接请求报文段
+ 序号字段seq:被设置了一个初始值x，作为TCP客户端进程所选择的初始序号

请注意：**TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号**

**2、服务器收到信号后，发送第二次握手报文**

![服务器收到信号后](https://img-blog.csdnimg.cn/20210205232429727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

TCP服务器进程收到客户端发送的TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送**TCP连接请求确认报文段**，并进入同步已接收状态


TCP连接请求确认报文段首部中有几个关键数据位：

+ 同步位SYN和确认为ACK：都设置为1，表明这是一个TCP连接请求确认报文段。
+ 序号字段seq：设置了一个初始值y，作为TCP服务器进程所选择的初始序号。
+ 确认号字段ack:值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认。

值得注意的是：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号

**3、发送方接收到确认报文后，开始第三次握手：**

![发送方进行第三次握手](https://img-blog.csdnimg.cn/20210205233459631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个**普通的TCP确认报文段**，并进入连接已连接状态


普通的TCP确认报文段首部中有以下重点数据位：

+ 确认位ACK:设置为1，由于没有SYN同步字段，表明这是一个普通的TCP确认报文段，表示已确认收到建立连接报文。

+ 序号字段seq:设置为x+1，因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1（SYN字段报文需要消耗一个序号）

+ 确认号字段ack：设置为y+1，这是对TCP服务器进程所选择的初始序号的确认

  值得注意的是：TCP规定普通的TCP确认报文段(只有ACK没有SYN)可以携带数据，但如果不携带数据，则不消耗序号

![三次握手完毕](https://img-blog.csdnimg.cn/20210205233515988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

## 8、拥塞控制

- **拥塞**指的是**某段时间内**，若对网络中的**某一资源的需求超过了该资源所能提供的可用部分**，网络性能就要变坏。
- 在计算机网络中的资源包括链路容量（带宽）、交换节点种的缓存和处理机等。
- 若出现**拥塞而不进行控制**，整个网络的**吞吐量将随输入负荷的增大而下降**。
- 可以将拥塞形象的理解为**堵车**。

![拥塞情况](https://img-blog.csdnimg.cn/20210205170452296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

+ 绿色指的是**理想情况**下不发生拥塞的情况，此时吞吐量与输入负载相等。当网络资源数被全部利用时，吞吐量不再增长。
+ 红色线指的是出现**拥塞不进行处理**，会导致吞吐量下降，直到吞吐量为零，产生死锁现象。
+ 蓝色线是在出现拥塞后采用拥塞控制措施，使吞吐量保持在一定水平。

**拥塞算法的基本思路：**

1、发送方维护一个叫做拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态转换

+ 拥塞窗口的维护原则：只要没有网络出现拥塞，拥塞窗口就再增大一些，只要网络出现拥塞，拥塞窗口就减少一些。
  + 判断网络拥塞的依据：没有按时收到应到达的确认报文（发生超时重传）

2、发送方将拥塞窗口作为发送窗口swnd，即：swnd = cwnd
3、维护一个慢开始门限ssthresh状态便变量，其维护原则为:

![img](https://img-blog.csdnimg.cn/20210205172001338.png)

**慢开始算法：**

- 慢开始算法是用来**确定网络的负载能力或拥塞程度**。算法实现是**由小到大逐渐增大（以倍数增长）拥塞窗口数值**。慢开始指的是一开始网路注入的报文段少，并不是指拥塞窗口cwnd的增长速度慢。

![坐标轴情况3](https://img-blog.csdnimg.cn/20210205173731557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

此时可以看出，**拥塞窗口已达到慢开始门限SSTHRESH,**此时，**慢开始算法使用阶段结束**，**开始拥塞避免算法阶段**。

**避免拥塞算法：**

- 拥塞避免算法让**拥塞窗口 cwnd 缓慢地增大（每伦窗口大小+1）**，避免出现拥塞。
- 拥塞避免阶段，具有 **“加法增大” (Additive Increase)** 的特点。
- 拥塞避免算法并不能完全避免拥塞，只是在拥塞避免阶段将容易拥护的窗口控制为按线性规律增长，是网络比较不容易出现拥塞。

![坐标轴情况5](https://img-blog.csdnimg.cn/20210205174101695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

循环重复此传输过程，若出现以下情况：

![出现报文段丢失情况](https://img-blog.csdnimg.cn/2021020517424021.png)

![重传计时器超时](https://img-blog.csdnimg.cn/20210205174329240.png)

出现重传计时器超时后，判断网络很可能出现了拥塞，进行以下工作：

1. **将ssthresh值更新为拥塞时cwnd值的一半**
2. **将cwnd值减少为1，重新开始直行慢开始算法**

对于以上两个算法的完整示意图：

![两个算法的完整示意图](https://img-blog.csdnimg.cn/20210205174838531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

## 9、滑动窗口

- 比如说应用程序要发的数据一共有1200byte，那就以**字节流**的形式，**流到发送端的传输层缓存。**
- 传输层自己决定，按每100byte进行分段，或者叫做分组，然后编上号。
  - ![image-20201228173911645](https://i.loli.net/2020/12/28/lQnTu46kYzWRvsx.png)
- 详细过程
- ![图片1](https://i.loli.net/2020/12/28/oODgnzPwGQBA4vh.png)

## 10、HTTP

超文本传输协议HTTP

HTTP：HyperText Transfer Protocol

- HTTP定义了**浏览器（万维网进行）怎样向万维网服务器请求万维网文档**，以及**万维网服务器怎么样把万维网文档传送给浏览器**。

![HTTP举例](https://img-blog.csdnimg.cn/20210208012003776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

+ 首先客户进程会利用80端口和服务器建立**TCP请求**，然后通过该连接发送HTTP请求报文。
+ 服务器收到请求报文后也会通过该连接发送HTTP响应报文。

- HTTP/1.0采用**非持续连接**方式。该方式下，**每次浏览器要请求一个文件都要与服务器建立TCP连接，当收到响应后就立即关闭连接。**

![非持续连接示例](https://img-blog.csdnimg.cn/20210208012429614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

在这种方式下，在建立阶段的第三次握手会携带**HTTP请求报文**进行发送，每次请求一次数据都需要**花费2RTT + 文档的传输时延**。

因此存在以下弊端：

![1.0弊端](https://img-blog.csdnimg.cn/20210208012558486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

HTTP/1.1采用**持续连接**方式。该方式下，**万维网服务器在发送响应后仍然保持这条连接**，使**同一个客户和该服务器可以在这条连接上继续传送后续的HTTP报文**。这样子并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。

![提高HTTP/1.1效率](https://img-blog.csdnimg.cn/20210208012846687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

![小结](https://img-blog.csdnimg.cn/20210208020712383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05pbXJvZF9f,size_16,color_FFFFFF,t_70)

## 11、get和post的区别

1、传送方式：get通过地址栏传输，post通过报文传输。

2、get数据放在请求的url中，安全性更差，post的所有操作对用户来说是不可见的

3、传送长度：get参数有长度限制（受限于url长度），而post无限制

4、get比post执行效率好

## 12、mac地址

**MAC地址**（**英语：Media Access Control Address）**，直译为**媒体存取控制位址**，也称为**局域网地址**（LAN Address），**MAC位址**，**以太网地址**（Ethernet Address）或**物理地址**（Physical Address），它是一个用来确认网络设备位置的位址。在[OSI模型](https://baike.baidu.com/item/OSI模型)中，第三层网络层负责[IP地址](https://baike.baidu.com/item/IP地址)，第二层数据链路层则负责MAC位址 。MAC地址用于在网络中唯一标示一个[网卡](https://baike.baidu.com/item/网卡)，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址 。

# 操作系统

## 1、进程通信方式

进程间通信主要包括管道、系统IPC（包括消息队列、共享内存、信号量、信号等）、以及套接字socket。

https://zhuanlan.zhihu.com/p/104713463

- **1.管道：**
  - 管道主要包括无名管道和命名管道:**普通匿名管道**可用于具有亲缘关系的**父子进程间的通信**，**有名管道**除了具有管道所具有的功能外，它还**允许无亲缘关系进程间的通信**。
  - 1.1 普通匿名管道PIPE：
    - 1)它是半双工的（即某一时间段内数据只能在一个方向上流动），具有固定的读端和写端
    - 2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
    - 3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是**它不是普通的文件**，并**不属于其他任何文件系统**，并且**只存在于内存中**。
  - 1.2 命名管道FIFO：
    - 1)FIFO可以在无关的进程之间交换数据
    - 2)FIFO有路径名与之相关联，**它以一种特殊设备文件**形式**存在于文件系统中**。
    - 3)其他的跟普通管道一样，它也时半双工的，各进程应该互斥访问
  - **自己总结的：管道**
    - **特点**：①管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿；②并且是管道是**单向传输**的，要想同时双向得用两个管道；③**a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回**。
    - **优缺点**：这种方式，通信效率低下（因为单向，并且a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回），不适合频繁通信的进程。优点是简单，能够保证数据被拿走。
- 2.系统IPC（Inter-Process Communication）：
  - 2.1 **消息队列**
    - 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 （消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点) 具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；
    - 特点：
    - 1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
    - 2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
    - 3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。
  - **自己总结的：消息队列**
    - 特点：例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，然后进程a就可以返回了，**无需等待**。b 进程需要的时候再去对应的消息队列取出来。
    - 优缺点：如果a进程发送的数据占用的内存比较大，并且两个进程通信特别频繁，那么意味着发送消息（也就是拷贝）这个过程要花很长时间读内存。
  - 2.2 **共享内存（Shared Memory）**
    - 它使得**多个进程可以访问同一块内存空间**，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等
    - 特点：
    - 1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取
    - 2)因为多个进程可以同时操作，所以需要进行同步、互斥（上锁）
    - 3)**信号量+共享内存通常结合在一起使用**，信号量用来同步对共享内存的访问
  - **自己总结的：共享内存**
    - 特点：解决消息队列那个发送消息的拷贝操作所带来的时间开销。
    - 可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。
  - 2.3 **信号量semaphore**（用于进程同步、进程互斥的，**主要是配合共享内存使用**，自己并不能用作进程通信）
    - 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量**用于实现进程间的互斥与同步**，而**不是用于存储进程间通信数据**。
    - 特点：
    - 1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
    - 2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
    - 3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
    - 4)支持信号量组。
  - **自己总结的：信号量**
    - 主要是配合共享内存使用，用于互斥或者同步访问共享内存。它自己并不能用于进程通信
  - 2.4 信号signal（没听过）
    - 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- 3.套接字SOCKET

  - socket也是一种进程间通信机制，与其他通信机制不同的是，它**可用于不同主机之间的进程通信**。
  - 自己总结的：SOCKET
    - 在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。

## 2、进程申请资源的位置

## 3、用户态和内核态

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式包括：系统调用，异常和中断（这其实本质上都是中断）。

**为什么区分用户态和内核态**

- 为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。
- 辅助理解：**核心态**（又称为系统态），在此状态下，**能能执行一切指令，访问所有的寄存器内容及存区域**（用一句不严谨的话说，啥都能干。） **用户态**，是相对核心态而言的，在此状态下**，只能执行特定的一些指令，特定的一些寄存器和一些特定的区域**。 那么问题来了，为什么要区分用户态和核心态呢？原因很简单，就是为了**保护操作系统**，因为操作系统中的一些重要数据，比如PCB，是不允许修改和破坏的。

## 4、死锁

#### 1.死锁发生的条件

死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的**四个必要条件**如下：

- 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。
- 请求和保持条件：A进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求（也就是A进程）阻塞，但该进程（A进程）不会释放自己已经占有的资源
- 不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放
- 环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链，链中的每一个进程已获得的资源同时被下一个进程所请求。

#### 2.解决死锁的方法

- **预防死锁**：（破坏死锁产生的四个必要条件中的一个或几个。）
  - 破坏互斥条件：把只能互斥使用的资源改造为允许共享使用
  - 破坏请求和保持条件：资源一次性分配，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。
  - 破坏不剥夺条件：方法①：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。方法②：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（例如剥夺调度方式，就是剥夺CPU，也可以按这个思想剥夺任何资源）
  - 破坏循环等待条件：可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。
- **避免死锁**：（用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)）
  - **在资源分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源分配请求。
  - 所谓**安全序列**，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是**安全状态**。当然**，安全序列可能有多个**。如果分配了资源之后，系统中找不出任何一个安全序列，系统接下来就进入了**不安全状态**。
  - 简洁版：
    - 可利用资源向量，最大需求矩阵，分配矩阵，需求矩阵（参考王道OS笔记）
    - 每次试探着允许分配，然后进行安全性检查，一旦找不出一个安全序列，那么就拒绝这次请求
- **死锁检测和接触**：（允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措
  施解除死锁。）
  - 死锁检测算法:用于检测系统状态，以确定系统中是否发生了死锁。
  - 死锁解除算法:当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。

## 3、缺页中断

一、什么是缺页中断？

进程线性地址空间里的页面不必常驻内存，在执行一条指令时，如果发现他要访问的页没有在内存中（即存在位为0），那么停止该指令的执行，并产生一个页不存在的异常，对应的故障处理程序可通过从外存加载该页的方法来排除故障，之后，原先引起的异常的指令就可以继续执行，而不再产生异常。

二、页面调度算法

将新页面调入内存时，如果内存中所有的物理页都已经分配出去，就按照某种策略来废弃整个页面，将其所占据的物理页释放出来；

## 4、多个线程按顺序打印

1、使用锁

2、使用p、v及信号量，p申请资源，v释放资源

