## 1.static关键字

- 全局静态变量
  - 链接性变为内部，被static关键字修饰过的全局变量只能在当前cpp文件中访问
- 静态函数
  - 链接性变为内部，被static关键字修饰过的函数只能在当前cpp文件中访问
- 局部静态变量
  - 作用域仍为局部作用域，生命周期为整个程序运行期间
- 类的静态成员变量
  - 不再是某个对象特有的，而是整个类共享的
- 类的静态函数成员
  - 对静态函数成员的引用不需要用对象名，直接类名::静态函数成员。静态成员函数主要用于处理该类的静态数据成员

## 2.TCP、UDP的区别

- UDP无连接，TCP有连接
- UDP首部长度固定，TCP首部长度可变
- UDP面向报文，UDP对应用层交下来的报文，既不合并，也不拆分，保留这些报文的边界；TCP面向字节流，TCP的数据报文段的长度不固定
- UDP是尽最大努力交付，不保证可靠交付。TCP是可靠交付：无差错，不丢失，不重复，按序到达。
- UDP没有拥塞控制，网络拥塞，不会影响源主机的发送效率；TCP有流量控制，来协调两台计算机之间的通信速率。TCP有拥塞控制，协调网络上所有使用TCP协议的设备，避免出现网络拥塞。
- UDP适用于对实时性要求高的场景，比如微信电话、微信视频；TCP适用于需要保证数据的完备性时。比如下载文件、在线看视频。

## 3.TCP保证可靠传输的协议有哪些

- 停止等待协议（序号、确认应答、超时重传机制）
  - 序号：对TCP缓存里的数据按字节编上序号。
  - 确认应答：数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认号说明了接收方下一次需要接收的数据序号。
  - 超时重传机制：如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间（超时重传时间RTO）后会进行重传。这个时间（超时重传时间RTO）一般是RTT(报文段往返时间）+一个偏差值。
- 连续ARQ：自动重传请求。
  - 长时间没收到确认包，就自动重发
- 滑动窗口协议：
  - 发一个窗口就等待一次。收到确认后，往后滑动窗口。
  - （意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。TCP利用窗口控制提高了传输速度。）
- 高速重发控制/快速重传
  - 两种重传机制：
    - 一种是停止等待里提到的超时重传机制。如果发送方迟迟未收到确认应答，在等待一定时间（超时重传时间RTO）后会进行重传。
    - 另一种是快重传机制。使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发。即当如果发送端收到一个包的三次应答包后，立即重传，比超时重传更高效

## 4.TCP的拥塞控制使用的算法和具体过程

- 流量控制：
  - 由确认包里的window字段控制。一个发送端一个接收端，调节发送速率
- 拥塞控制：
  - 网络中所有使用使用TCP通信的计算机，需要根据网络的状态来调整他们的发送速率。
  - 拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载。
  - 为了进行拥塞控制，TCP的**发送方要维持一个拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。**
- 拥塞控制中的算法：
  - 慢开始（一开始的窗口很小，指数增大到慢开始门限ssthresh）
    - 最开始发送方的拥塞窗口为1（1是指一个分组，不是一个byte），由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次（指的是把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认），拥塞窗口cwnd*2。当cwnd超过慢开始门限ssthresh，则使用拥塞避免算法线性增加，不再是指数增加了，避免cwnd增长过大。
  - 拥塞避免算法（达到慢开始门限ssthresh后，线性增加）
    - 每经过一个传输轮次，就把发送方的拥塞窗口cwnd加1。
  - 快重传算法（接收方一旦发现失序报文段到达，即大序号的先来了，小序号的一直没来，就发送三次重复确认）
    - 接收方发现失序报文，则意味着丢包了，立马发送三次重复的确认表示快重传。
    - 发送方收到三次重复的确认，则知道这是快重传的意思。快重传即意味着丢包了，丢包即意味着网络有可能快要拥塞了。
    - 发送方立马重传丢失的数据包，并启动快恢复。
  - 快恢复
    - 慢开始门限ssthresh乘法减半（即更新慢开始门限为当前cwnd的一半，注意是cwnd的一半，不是ssthresh的一半），然后将当前的cwnd设置为更新后的慢开始门限，并且之后采用拥塞避免算法线性增加cwnd。
  - ![image.png](https://i.loli.net/2021/01/11/7ZyuDvzdXcLnglW.png)

## 5.内存泄漏的原因及解决办法

- 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。
- **智能指针主要用于管理在堆上分配的内存**，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。
- delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。

## 6.实现一下strcmp方法

```c++
//逐位比较，相等就下一位，不等就返回当前两个字符的差值。
int mystrcmp(const char* str1,const char* str2){
    while(*str1!='\0' && *str2!='\0' && *str1==*str2){
        str1++;
        str2++;
    }
    return *str1-*str2;
}
```

## 7.讲一下c++面向对象的特性

- 类classes（包括构造函数和析构函数），**抽象，封装，继承，多态**，虚函数（动态绑定）等等。

## 8.讲一下类的private和protected的区别

- **派生类中的成员函数：**可以**直接访问基类中的public和protected成员**，但不能直接访问基类的private成员；
- **通过派生类构造的对象：只能访问public成员。**基类的protected或者派生类的protected也都是无法直接访问的。（public继承方式的作用）
- 换句话说
  - 保护成员，在类外跟Private一样，不能直接访问。
  - 对于其派生类来说，它与 public 成员的性质相同

## 9.网关的作用是什么

- 网关(Gateway)又称网间连接器
- 不同的网段（网络号）上的设备通信时，必须经过网关。如果果**网络A**中的主机发现**数据包**的目的主机**不在**本地网络中，就把数据包转发给它**自己的网关**，再由网关转发给网络B的网关，网络B的网关再转发给网络B的相应主机。

## 10.三次握手、四次挥手

- ![image-20210112160320415](http://pichost.yangyadong.site/img/image-20210112160320415.png)
- ![image-20210112163212081](http://pichost.yangyadong.site/img/image-20210112163212081.png)
- ![image-20210112160934843](http://pichost.yangyadong.site/img/image-20210112160934843.png)

## 11.TIME_WAIT

- 理由一：以防第四次挥手信息丢失，导致B没有收到第四次挥手。如果第四次挥手B迟迟没有收到，那么B会重传第三次挥手，这样A收到第三次挥手，也会重发第四次挥手
- 理由二：2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。防止下一个新的连接中出现旧的连接请求报文段。

## 12.OSI七层

- 应用层
- 表示层
  - 对数据进行编码、加密和压缩，主要包括的协议为JPEG压缩、ASCII编码、Unicode编码等等。
- 会话层
  - 服务端和客户端建立会话，会话层连接面向用户，就一个。或者是SSL/TLS建立的会话。
- 传输层
  - 提供端到端的接口可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP
- 网络层
  - 负责为数据包选择路由，传输单位为数据包,主要包括的协议为ARP、IP、ICMP、IGMP
  - 即不同网段间传输
- 数据链路层
  - 将数据包封装成能够在不同网络间传输的帧，传输单位为帧,主要包括的协议为CSMA/CD（以太网） 、PPP（点对点，ADSL拨号上网）
  - 即同一网段内传输
- 物理层
  - 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45

## 13.快排

- 升序

  - ```c++
    class Solution {
    public:
        vector<int> getLeastNumbers(vector<int>& arr, int k) {
            quickSort(arr,0,arr.size()-1);
            vector<int> res(arr.begin(),arr.begin()+k);//左闭右开
            return res;//返回前k个小的数
        }
        void quickSort(vector<int>&arr,int l,int r){//升序
            if(l>=r)
                return;
            int i=l,j=r;
            while(i<j){
                while(i<j && arr[j]>=arr[l]) j--;//找到第一个比哨兵小的数
                while(i<j && arr[i]<=arr[l]) i++;
                swap(arr[i],arr[j]);
            }
            swap(arr[i],arr[l]);
            quickSort(arr,l,i-1);
            quickSort(arr,i+1,r);
        }
    };
    ```

- 降序

  - ```c++
    class Solution {
    public:
        int findKthLargest(vector<int>& nums, int k) {
            quickSort(nums,0,nums.size()-1);
            return nums[k-1];//返回第k个最大的数
        }
        void quickSort(vector<int>& nums,int l,int r){
            if(l>=r)
                return;
            int i=l,j=r;
            while(i<j){//升序降序仅仅是<= 和 >=反了反
                while(i<j && nums[j]<=nums[l]) j--;//找到第一个比哨兵大的数
                while(i<j && nums[i]>=nums[l]) i++;
                swap(nums[i],nums[j]);
            }
            swap(nums[i],nums[l]);
            quickSort(nums,l,i-1);
            quickSort(nums,i+1,r);
        }
    };
    ```


## 14.你理解的虚函数和多态（对象中有虚指针，每个类有一个虚表，对象里的虚指针指向虚表，不同的类虚表中存有各个虚函数的入口指针）

#### 多态

多态的实现主要分为静态多态和动态多态，

- 静态多态主要是重载（函数重载，运算符重载），在编译的时候就已经确定；
- 动态多态是用虚函数机制实现的，在运行期间动态绑定。

举个例子：一个父类(基类)类型的指针指向一个子类（派生类）对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。

#### 虚函数

为什么运行时可以动态绑定呢？运行时没有编译环境了，只有操作系统，谁帮我们确定该执行哪个函数体呢？

答：其实包含在对象里！对象里的虚指针就决定了它真正应该调用的函数是哪个，而不取决于该对象被什么指针指向（管你是base指针还是derived指针，因为实际上是由对象里的虚指针决定的）。

虚函数的实现：在有虚函数的类中，编译器会为每个**有虚函数的类**创建一个**虚函数表**，该虚函数表将被该类的所有对象共享。虚表指针在类对象中，每个同类对象中都有个一个vptr，指向内存中的vtable，所有同类对象，共享一个vtable，但是**每个对象都自带一个vptr**指向这个vtable,虚表指针是对象的第一个数据成员，虚表指针的初始化发生在构造函数过程中。类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类（派生类）继承了父类（基类）的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

#### 总结：

- 每个多态类（Based、derived）都有一个虚表，基类有基类的虚表，派生类有派生类的虚表，虚表里记录了应该调用的各个虚函数的地址。
- 每个多态类对象都有一个**虚指针，它指向应该调用的虚表的地址**，通过多态类型的指针或引用调用成员函数时，**通过虚指针找到虚表，进而找到所调用的虚函数的入口地址**



- 虚表

  - **每个多态类有一个虚表**（virtual table）
  - 也就是说Base和Derived类都将有自己的虚函数表
  - **虚表中有当前类的各个虚函数的入口地址**
  - **每个对象有一个指向当前类的虚表的指针（虚指针vptr）**
  - 在编译时，编译器做好虚表，等待运行时查找

- 动态绑定的实现

  - 构造函数中为对象的虚指针赋值
  - 通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址
  - 通过该入口地址调用虚函数。

![NSJHxO.png](https://s1.ax1x.com/2020/06/14/NSJHxO.png)

- Derived类的虚表会覆盖那些重新定义的虚函数，没有重新定义的，那么还是指向基类
- 所以，**虽然一个Derived对象被Base指针指向，但是该Derived实例（对象）里的虚指针VFT其实仍然指向Derived类的虚函数表，就可以实现运行时多态了。**

## 15.虚（函数表）指针、虚（函数）表、虚函数的位置

#### virtual修饰符

- 如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。
- 如果该类是virutal继承而来的子类，则该类的**虚函数表指针和该类其他成员一起存储**。虚函数表指针指向只读数据段中的类虚函数表，**虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。**
- 如果类中成员是virtual属性，会隐藏父类对应的属性。

![image.png](https://i.loli.net/2020/09/21/RYCvAJWMU1tych8.png)

假如初始化方式是 A* obj=new A;

- 指针变量obj在栈
- 对象A的实例在堆
  - 对象A里有虚指针（存的地址指向虚表，即常量区地址，因为虚表存在roadata），各种成员变量等等（这些都存在堆里）
- 虚指针指向某个类（基类或者某派生类）虚表，**虚表存在c++中内存五区的常量存储区（对应rodata段）**
  - 虚表中存着各虚函数的入口指针（各指针地址指向代码区，因为各虚函数函数存在代码区text）
- 各虚函数存在代码区
  - text段

#### 3.特别说一下虚函数表的位置

- 虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，对应于c++中内存五区的常量存储区（文字常量区）

## 16.单例模式

- 单例懒汉：C++11局部静态变量

  - 函数中的局部静态变量指向唯一实例

  - **在C++11中，局部静态变量的访问是线程安全的**，使用函数内的局部静态对象，这种方法不用加锁和解锁操作

  - ```c++
    class single{
        private:
        	single(){};//私有化构造函数
        public:
        	~single(){};
        	static single* getInstance(){
                static single instance;//在C++11中，局部静态变量的访问是线程安全的，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。
                return &instance;
            }
    }
    ```

- 单例懒汉：双检锁

  - **类内的私有静态指针变量（成员）指向唯一实例。**

  - 线程安全。第一个检保证效率，锁保证线程安全，第二个检也是用来保证线程安全

  - 双检：是指两个`if(p==nullptr)`。加锁其实只有一次。

  - ```c++
    class single {
    private:
    	single() {}//私有化构造函数
        static mutex m_mutex;//类成员静态数据成员声明
    	static single* p;
    public:
    	~single() {};
    	static single* getInstance() {
    		if (p == nullptr) {//第一个检保证效率
    			m_mutex.lock();//锁保证线程安全
    			if (p == nullptr) {//第二个检也是用来保证线程安全。以防同时有多个线程突破了第一重if，然后挨个获取了互斥锁，进入互斥锁内部。
    				p = new single;
    			}
    			m_mutex.unlock();
    		}
    		return p;
    	}
    
    };
    single*  single::p = nullptr;//类的静态数据成员必须在类外定义和初始化
    mutex single::m_mutex;
    ```

- 单例饿汉

  - 一上来就初始化，这是通过类外的`single* single::p = new single();`实现的。

    - 懒汉模式里对指针的初始化都是写成这样`single* single::p = NULL;`。 懒汉模式里执行new single()并对静态数据成员指针p 赋值是在getinstance()里。

  - **饿汉模式不需要用锁，就可以实现线程安全**。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。

  - ```c++
    class single {
    private:
    	single() {}
    	static single* p;
    public:
    	~single() {}
    	static single* getInstance() {
    		return p;
    	}
    	
    };
    single* single::p = new single();//懒汉是初始化为nullptr
    ```

## 17.线程池

https://blog.csdn.net/oyoung_2012/article/details/78958274

还没写完

```c++
class ThreadPool {
public:
	ThreadPool(int threadNum) {
		this->threadNum = threadNum;
		m_stop=false;
        sem_init(&m_sem,0,0);
        for(int i=0;i<threadNum;i++){
            thread* tmpThread=new thread(worker,this);
            threadVec.push_back(tmpThread);
        }
	}

    ~ThreadPool(){
        
    }
private:
	int threadNum;
	bool m_stop;
	vector<thread*> threadVec;
    sem_t m_sem;
	static void* worker(void* _thread_pool){
        ThreadPool* mythreadpool=(ThreadPool*) _thread_pool;
        mythreadpool->run();
        return nullptr;
    }
    void run(){
        while(!m_stop){
            
        }
    }
};
```

## 18.讲一下项目

- **socket()函数**创建一个创建IPv4的TCP socket，名字叫listenfd
- 创建一个sockaddr_in address;
  - 设置地址 0.0.0.0:12345
- **bind函数**把listenfd和地址address绑定
- **listen函数**创建了一个监听队列以存放待处理的客户连接，也就是开启监听
- 创建内核事件表epollfd，向内核事件表中注册"listenfd"这个socket文件的 可读事件
- 主线程while循环 **epoll_wait阻塞等待**内核事件表epollfd上监控的文件有事件。一个线程，监听多个IO事件
  - 是listenfd可读？那说明有新用户连接了
    - **accept函数**从从listen监听队列中接受一个连接，得到connfd
    - 将新的connfd添加到epollfd即内核事件表上

## 19.什么是IO复用

- IO复用：
  - 一个线程，管理多个IO事件（监听多个文件描述符）。
    - 在我的项目里就是：listenfd可读（有新的客户连接）、管道的读端可读了（定时器到时间了 或者 有其他的信号发送给本进程了）、某个connfd连接可读了（接收到客户发来的数据，比如是get、post请求）、某个connfd连接可写了（服务器要给客户发数据了，http响应）
  - 应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数把其中就绪的事件通知给应用程序
- 需要使用IO复用的场景
  - 服务器同时处理多个socket
  - 服务器同时处理监听socket和连接socket
    - 比如我们的web服务器
  - 服务器同时处理TCP和UDP请求
    - 同一个端口上的TCP和UDP，需要两个socket来监听
  - 服务器同时监听多个端口
    - 创建多个socket，分别绑定到各个端口上

## 20.阻塞IO与非阻塞IO

- 阻塞IO（阻塞的文件描述符）
  - 系统调用可能因为无法立即完成而被操作系统挂起。
  - 比如recv函数，如果connfd这个socket是阻塞的。如果没数据可读，而你又去recv了，它会一直等在那里，直到有数据可读。
- 非阻塞IO（非阻塞的文件描述符）
  - 系统调用总是立即返回。
  - 比如recv函数，如果connfd这个socket是非阻塞的。如果没数据可读，而你又去recv了，它会立即返回-1，errno设置为EAGAIN
- 上面两点就是为什么对于ET边缘触发模式，一定要设置为非阻塞IO的原因。
  - 因为，ET就说明，你必须得一次性把事件处理完。比如你收到了2KB数据，你就得使用while循环，把这2KB数据读取干净。如果你没有用while循环，没读干净，比如本次epoll你只读了1KB，还有1KB没读。那么epoll也不会再给你汇报说文件就绪了。
  - 所以用了ET，你必须得写while循环，而如果你用了while循环，connfd又是阻塞的IO，那么recv函数最后一定会阻塞住，因为没有数据可读了，你还让它去读。
  - 所以啊，用ET，一定得用非阻塞IO。即把connfd这个文件描述符设置为非阻塞的。因为对于非阻塞IO，recv函数发现没数据可读时，会立即返回-1而不会阻塞

## 21.同步IO与异步IO

- 同步IO
  - 用户代码自行完成IO操作
    - 比如代码使用send recv等系统调用，都属于用户自己完成的。
  - 常见的阻塞IO、IO复用 全都是同步IO。
- 异步IO
  - 内核把IO完成了，再告诉给应用程序
    - 内核完成需要使用aio_read()、aio_write等系统调用

## 22.同步线程与异步线程

- 同步线程（按照同步的方式运行的线程）
  - 线程自己从头到尾的运行，不需要外力驱动。
  - 比如：线程池中的处理http请求的子线程，一旦运行，就从头到尾的运行
- 异步线程（按照异步的方式运行的线程）
  - 受到信号、中断等系统事件的驱动运行。
  - 比如：主线程，就受到epoll_wait驱动
