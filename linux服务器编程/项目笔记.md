# 项目笔记

## 1.C++

### 1.sighandler_t类型（typedef void (*sighandler_t)(int)）

#### 先理解一下函数指针

函数指针的定义方式为：

```c
函数返回值类型 (* 指针变量名) (函数参数列表);

举例：
int(*p)(int, int);//定义了一个指针变量 p，该指针变量可以指向 "返回值类型为 int 型，且有两个整型参数"的 函数。p 的类型为 int(*)(int，int)。
```



```c
int Func(int x);   /*声明一个函数*/
int (*p) (int x);  /*定义一个函数指针*/
p = Func;          /*将Func函数的首地址赋给指针变量p*/
```

#### sighandler_t类型声明

`typedef void (*sighandler_t)(int);`

如何理解？利用`typedef int *apple;`来解释

```c
int *apple;//声明了一个 "指向整型变量的" 指针apple  (注意：定义只是一种特殊的声明)
typedef int *apple;//声明了一种 "指向整型变量的 "指针类型apple。apple是一种类型，可以像使用int一样去使用它。
```

现在，回过来看上面的这个函数原型 `typedef void (*sighandler_t)(int)`，盖住 typedef不看 ，再简单不过，`sighandler_t`就是一个函数指针，指向的函数接受一个整型参数并返回一个无类型指针 。加上typedef之后sighandler_t就是一种新的类型，就可以像int一样地去用它，不同的是它声明是一种函数指针，这种指针指向的函数接受一个整型参数并返回一个无类型指针 。

#### 练习

做一个更酷的练习，请看：`typedef char* (* c[10])(int **p);`

盖住typedef。c是一个拥有10个元素的数组，只不过这个数组c的元素有点特别，元素都是函数指针，并且它们所指向的这些函数统统都接受一个int二级指针，然后返回一个指向char的指针。加上typedef之后，c就不是一个数组了，而是一种“数组”类型了。

### 2.#program  once

防止重复包含。

它指的是防止你手写了一个A.h文件。又写了一个B.h文件。结果B还include了A。在main里 把A、B都include了进去，这样A就被重复包含了好几遍，会出现多次声明的问题。

### 3.string转char*类型

```c
char* c; 
string s="1234"; 
c = s.c_str(); 
```

### 4."\t"对应多少个空格

![image-20210319153439508](http://pichost.yangyadong.site/img/image-20210319153439508.png)

```c
cout<<"123"<<"\t"<<endl;// \t将补充5个空格，凑够8
cout<<"1234567"<<"\t"<<endl;// \t将补充1个空格，凑够8
cout<<"12345678"<<"\t"<<endl;// \t将补充8个空格。因为已经够8的倍数了
cout<<"123456789012345"<<"\t"<<endl;// \t将补充1个空格，凑够16
cout<<"1234567890123456"<<"\t"<<endl;// \t将补充8个空格。因为已经够8的倍数了
cout<<"12345678901234567"<<"\t"<<endl;// \t将补充7个空格，凑够24
cout<<"1234567890123456789"<<"\t"<<endl;// \t将补充5个空格，凑够24
cout<<"12345678901234567890123"<<"\t"<<endl;// \t将补充1个空格，凑够24
cout<<"123456789012345678901234"<<"\t"<<endl;// \t将补充8个空格。因为已经够8的倍数了
cout<<"1234567890123456789012345"<<"\t"<<endl;// \t将补充7个空格，凑够32
```

### 5.模板类的成员函数实现应该放在头文件中

- 模板类的成员函数实现应该放在头文件中
- 因为模板类本质上不是类，只有实例化之后才会编译生成.o文件
- 即thread_pool.h，不可以有对应的thread_pool.cpp

### 6.对于模板类指针

```c++
template<class T> 
class thread_pool{

}

thread_pool<T>* threadPool
    或者
thread_pool* threadPool
 	都可以
```

### 7.主线程退出后，子线程会不会退出

- 主线程程序return，间接调用了exit()函数，因为一个线程调用exit函数，导致整个进程的退出，系统回收所有的资源，当然所有的线程都退出了。
- 在主线程退出时，要想系统并不回收进程的所有资源，可以调用`pthread_exit();`然后等其他线程终止退出。

### 8.类方法的实现，在类内实现和类外实现的区别

为了减少时间开销，如果在类体中定义的成员函数中不包括循环等控制结构，C++系统会自动将它们作为内置(inline)函数来处理。

### 9.

## 2.数据库&设计模式&操作系统

### 1.单例模式（有懒汉、饿汉、双检锁等实现方式）

#### 概述

https://zhuanlan.zhihu.com/p/37469260

- 单例模式
  - 保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享
- 实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例（这是指双检锁懒汉或者饿汉模式，局部静态变量的懒汉模式中唯一实例就是局部静态变量），并用一个公有的静态方法（`static single* GetInstance（）`）获取该实例。
- 懒汉模式
  - 即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；
  - 双检锁、局部静态变量
- 饿汉模式
  - 即迫不及待，在程序运行时立即初始化。
  - 不用锁

#### 单例懒汉--双检锁（线程安全。第一个检保证效率，锁保证线程安全，第二个检也是用来保证线程安全）

```c
class single{
 private:
     //私有静态指针变量指向唯一实例
     static single *p; //注意，这个p切记不可delete。因为它是static的，所有该类对象共享的，虽然它是单例模式。（不会在每个对象中存储，整个类只存储一份）
 
     //静态锁，是由于静态函数只能访问静态成员
     static pthread_mutex_t lock; //static成员的寿命持续到程序结束，自行释放
 								
    								//注意：双检锁模式，p = new single;是new出来的，在主线程中，手动delete【single::getinstance()】返回的指                                            针即可，构造函数设为空就行（如果有其他内存空间需要释放，那么就在构造函数里释放）。
     //私有化构造函数
    single(){
        pthread_mutex_init(&lock, NULL);
    }
   

public:
     ~single(){}//析构函数不能私有化，因为手动调用delete时，会触发析构函数
    //公有静态方法获取实例
    static single* getinstance();
};

//pthread_mutex_t single::lock=PTHREAD_MUTEX_INITIALIZER;其实在类外写成这样，然后把构造函数里的pthread_mutex_init删了也行
pthread_mutex_t single::lock;//类的静态数据成员必须在类外定义和初始化。这相当于是使用默认构造函数来构造了互斥锁，真正的赋值（初始化）发生在构造函数里
single* single::p = NULL;//类的静态数据成员必须在类外定义和初始化

single* single::getinstance(){//公有静态方法获取实例，方法实现
    if (NULL == p){//说明还没有获取过单例
        pthread_mutex_lock(&lock);//加锁
        if (NULL == p){//检测是否获取过单例
            p = new single;
        }
        pthread_mutex_unlock(&lock);
    }
    return p;
    }
```

- 为什么要用双检测，只检测一次不行吗？
  - 如果把上边的`if(NULL == p)`删了。**依然可以保证线程安全，缺点是：**在每次调用获取实例的方法时，都需要加锁，这**将严重影响程序性能**。即已经获取过一次实例以后，再次调用这个函数时，依然还要加锁，再判断是否已经创建实例。获取过一次实例以后，每次进入依然要加锁，严重影响程序性能。
  - 如果把下边的`if(NULL == p)`删了。**不能保证线程安全。**原因是：判断是否获取过实例在加锁的外围，在多线程环境下，可能有多个线程判断if成功，进入if内，然后因为有锁的保护，将一个线程一个线程地加锁，然后`p =new single`，然后解锁。所有线程都可能执行了一次`p = new single;`，这将造成内存泄露，也就是非线程安全，即多线程环境下不安全。
- 所以双检锁（双重检查+互斥锁）的意思是
  - 第一重检查：保证在获取到单例之后，再次运行该函数时的效率，直接if失败返回
  - 互斥锁：加锁用来保证同一时刻只能有一个线程进入第二次if判断，保证了线程安全（保证同一时刻只能有一个线程进入锁内）。
  - 第二重检查：以防同时有多个线程突破了第一重if，然后挨个获取了互斥锁，进入互斥锁内部。互斥锁内部的这第二重检查，也是用来保证多线程环境下，依然只有一个单例，且不会内存泄露，也就是保证了线程安全。

#### 单例懒汉--C++局部静态变量（线程安全）

在C++11中，局部静态变量的访问是线程安全的，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。

```c
 class single{
 private:
     single(){}//私有化构造函数
 public:
     ~single(){}
     static single* getinstance();//公有静态方法获取实例
 
 };

single* single::getinstance(){//公有静态方法获取实例，方法实现
    static single obj;
    return &obj;
}
```

如果使用C++11之前的标准，还是需要加锁，这里同样给出加锁的版本。

```c
 class single{
 private:
     static pthread_mutex_t lock;
     single(){//私有化构造函数
         pthread_mutex_init(&lock, NULL);
     }
     
 
 public:
    ~single(){}
    static single* getinstance();//公有静态方法获取实例

};

pthread_mutex_t single::lock//类的静态数据成员必须在类外定义和初始化;这相当于是使用默认构造函数来构造了互斥锁，真正的赋值（初始化）发生在构造函数里

single* single::getinstance(){//公有静态方法获取实例，方法实现
    pthread_mutex_lock(&lock);
    static single obj;
    pthread_mutex_unlock(&lock);
    return &obj;
}
```

备注：

- 单例懒汉双检锁
  - 双检锁模式，p = new single;是new出来的。即真正的单例在堆上，在主线程中，需要手动delete `single::getinstance()`返回的指针，构造函数设为空就行（如果有其他内存空间需要释放，那么构造函数就不能为空了。比如需要一个一个的摧毁连接池）。
- 单例懒汉局部静态变量
  - 在局部静态变量实现中，真正的单例是一个局部静态变量，在主线程中，什么都不用做，等待程序结束，自行析构局部静态变量，该单例就会调用析构函数了

#### 饿汉模式（不需要用锁，就可以实现线程安全；但存在隐藏的问题）

- 饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。
- 注意：一上来就初始化，这是通过`single* single::p = new single();实现的。
  - 懒汉模式里对指针的初始化都是写成这样`single* single::p = NULL;`。 懒汉模式里执行new single()并对静态数据成员指针p 赋值是在getinstance()里。
- 隐藏的问题是：
  - 饿汉模式虽好，但其存在隐藏的问题，在于非局部（non-local）静态对象（函数外的static对象），在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。
  - 即C++对于定义于不同文件内的non-local statci对象的初始化次序并无明确定义。
  - 通俗点说，`single* single::p = new single();`这句话，不知道会在什么时候执行。确实是在程序一开始时，但是跟其他cpp文件内定义的non-loal static对象谁先谁后，并无明确定义。如果你在另一个non-loal static对象的初始化中使用了这个指针p，这将导致不确定行为。

```c
 class single{
 private:
     static single* p;
     single(){}
  	 
 
 public:
     ~single(){}
     static single* getinstance();
 
};

single* single::p = new single();//类的静态数据成员必须在类外定义和初始化

single* single::getinstance(){
    return p;
}

//测试方法
int main(){

    single *p1 = single::getinstance();
    single *p2 = single::getinstance();

    if (p1 == p2)
        cout << "same" << endl;

    system("pause");
    return 0;
}
```



### 2.三种线程同步机制

- POSIX信号量

  - 信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V)
  - 假设有信号量SV，对其的P、V操作如下：
    - P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行（wait）
    - V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一（post）

- 互斥量（互斥锁、二进制信号量）

  - 互斥锁,也称互斥量,可以保护关键代码段,以确保独占式访问.
  - 当进入关键代码段,获得互斥锁将其加锁；离开关键代码段,唤醒等待该互斥锁的线程.
  - mutex是用来保证线程互斥的，防止不同的线程同时操作同一个共享数据

- 条件变量

  - 条件变量提供了一种线程间的通知机制，当某个共享数据达到某个值时，唤醒等待这个共享数据的线程

  - 如果说【互斥锁】是用于【同步】【线程对共享数据的访问】的话，那么【条件变量】则是用于【在线程之间】【同步】【共享数据的值】。

    - 条件变量就是一个变量，用来自动阻塞一个线程，直到某特殊情况发生为止。
    - 条件变量是用来等待事件
    - 通常条件下变量和互斥锁同时使用

  - //条件变量。相当于一种资源的阻塞队列。

  - //条件变量condition_variable只能和unique_lock一起使用
    //condition.wait()函数都在会阻塞时，自动释放锁权限，即调用unique_lock的成员函数unlock()，以便其他线程能有机会获得锁

  - ```c++
     std::condition_variable con1;//条件变量。相当于一种资源的阻塞队列。
     std::mutex my_mutex;//互斥量，就是最简单的进程互斥。
    std::unique_lock<std::mutex> lk(my_mutex);
    
    con1.wait(lk,[this]()->bool{return counter==2;}); // 阻塞当前线程，直到条件变量被唤醒。并且会释放lk，即解锁，好让其他线程执行。 [this]()->bool{return counter==2;}是Lambda表达式
    
     con1.notify_one();//若任何线程在con1上等待，则调用 notify_one 会解阻塞(唤醒)等待线程之一。
            //换句话说，con1.notify_one()是con1.wait()的唤醒
    
    //伪唤醒，底层设计时没有保证每次执行wait都是由notify唤醒，所以需要自己加个条件（比如lambda表达式）判断一下，是不是真的可以执行了
    ```

### 3.RAII

#### **RAII**

- RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.
- 在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定
- **RAII的核心思想是将资源或者状态与对象的生命周期绑定**，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子

### 4.mysql查询，遍历输出

### 5.生产者-消费者模型

- 其中，process_msg相当于消费者，enqueue_msg相当于生产者，struct msg* workq作为缓冲队列。
- 生产者和消费者是互斥关系，两者对缓冲区访问互斥，同时生产者和消费者又是一个相互协作与同步的关系，只有生产者生产之后，消费者才能消费。

```c
 #include <pthread.h>
 struct msg {
   struct msg *m_next;
   /* value...*/
 };
 
 struct msg* workq;
 pthread_cond_t qready = PTHREAD_COND_INITIALIZER;//条件变量
 pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;

void process_msg() {
  struct msg* mp;
  for (;;) {
    pthread_mutex_lock(&qlock);//上锁
    //这里需要用while，而不是if
    while (workq == NULL) {
      pthread_cond_wait(&qread, &qlock);//条件变量_wait
    }
    mq = workq;
    workq = mp->m_next;
    pthread_mutex_unlock(&qlock);
    /* now process the message mp */
  }
}

void enqueue_msg(struct msg* mp) {
    pthread_mutex_lock(&qlock);
    mp->m_next = workq;
    workq = mp;
    pthread_mutex_unlock(&qlock);
    /** 此时另外一个线程在signal之前，执行了process_msg，刚好把mp元素拿走*/
    pthread_cond_signal(&qready);//条件变量_唤醒
    /** 此时执行signal, 在pthread_cond_wait等待的线程被唤醒，
        但是mp元素已经被另外一个线程拿走，所以，workq还是NULL ,因此需要继续等待*/
}
```

### 6.条件变量

条件变量提供了一种线程间的通知机制，当某个共享数据达到某个值时,唤醒等待这个共享数据的线程。

#### 基础API

- pthread_cond_init函数，用于初始化条件变量
- pthread_cond_destory函数，销毁条件变量
- pthread_cond_broadcast函数，以广播的方式唤醒**所有**等待目标条件变量的线程
- pthread_cond_wait函数，用于等待目标条件变量。该函数调用时需要传入 **mutex参数(加锁的互斥锁)** ，函数执行时，先把调用线程放入条件变量的请求队列，然后将互斥锁mutex解锁，当函数成功返回为0时，表示重新抢到了互斥锁，互斥锁会再次被锁上， **也就是说函数内部会有一次解锁和加锁操作**.

#### 使用pthread_cond_wait方式如下：

```c
pthread _mutex_lock(&mutex)

while(线程执行的条件是否成立){ //while 资源==false，就去阻塞在信号上等待唤醒
    pthread_cond_wait(&cond, &mutex);
}

pthread_mutex_unlock(&mutex);
```

#### pthread_cond_wait执行后的内部操作分为以下几步：

- 将线程放在条件变量的请求队列后，内部解锁。即在内部解开了mutex，但是还没有退出这个pthread_cond_wait函数，解锁后依然阻塞在函数内部，等待条件变量唤醒。
- 线程等待被pthread_cond_broadcast信号唤醒或者pthread_cond_signal信号唤醒，唤醒后去竞争锁。竞争锁即去竞争锁的使用权，即上锁
- 若竞争到互斥锁，内部再次加锁。没竞争到就排队等着使用锁

#### pthread_cond_wait细节

- 1.pthread_cond_wai前要加锁，为什么要加锁？

  - 多线程访问，为了避免资源竞争，所以要加锁，使得每个线程互斥的访问公有资源。

- 2.pthread_cond_wait内部（条件变量没有被唤醒，要把锁解开，然后继续阻塞在pthread_cond_wait内部等待条件变量唤醒）为什么要解锁？

  - 如果while或者if判断的时候，满足执行条件，线程便会调用pthread_cond_wait阻塞自己，此时它还在持有锁，如果他不解锁，那么其他线程将会无法访问公有资源。
  - 具体到pthread_cond_wait的内部实现，当pthread_cond_wait被调用线程阻塞的时候，pthread_cond_wait会自动释放互斥锁。

- 3.为什么要把调用线程放入条件变量的请求队列后再解锁？

  - 线程是并发执行的，如果在把调用线程A放在等待队列之前，就释放了互斥锁，这就意味着其他线程比如线程B可以获得互斥锁去访问公有资源，这时候线程A所等待的条件改变了，但是它没有被放在等待队列上，导致A忽略了等待条件被满足的信号。
  - 倘若在线程A调用pthread_cond_wait开始，到把A放在等待队列的过程中，都持有互斥锁，其他线程无法得到互斥锁，就不能改变公有资源。
  - 所以这样的操作目的都是，让pthread_cond_wait函数不会错过目标条件变量的任何变化，也不会占着锁导致其他线程无法使用。

- 4.为什么pthread_cond_wait被唤醒后，最后还要自动加锁？

  - 将线程放在条件变量的请求队列后，将其解锁，此时等待被唤醒，若成功竞争到互斥锁，再次加锁。

- 5.为什么判断线程执行的条件用while而不是if？

  - 一般来说，在多线程资源竞争的时候，在一个使用资源的线程里面（消费者）判断资源是否可用，不可用，便调用pthread_cond_wait，在另一个线程里面（生产者）如果判断资源可用的话，则调用pthread_cond_signal发送一个资源可用信号。

  - 在wait成功之后，资源就一定可以被使用么？答案是否定的，如果同时有两个或者两个以上的线程正在等待此资源，wait返回后，资源可能已经被使用了。

  - 再具体点，有可能多个线程都在等待这个资源可用的信号，信号发出后只有一个资源可用，但是有A，B两个线程都在等待，B比较速度快，获得互斥锁，然后加锁，消耗资源，然后解锁，之后A获得互斥锁，但A回去发现资源已经被使用了，它便有两个选择，一个是去访问不存在的资源，另一个就是继续等待，那么继续等待下去的条件就是使用while，要不然使用if的话pthread_cond_wait返回后，就会顺序执行下去。

  - 所以，在这种情况下，应该使用while而不是if:

  - ```
    while(resource == FALSE)
        pthread_cond_wait(&cond, &mutex);
    ```

  - 如果只有一个消费者，那么使用if是可以的。

## 9.备注

### 1.数据库连接池

#### 数据库连接池为什么用链表不用数组

- 链表里放的都是可用连接，每次从连接池申请一个连接，都是拿走的头结点，然后头结点就会被pop出去。
- 用数组的话，那么每次想申请一个连接，都得遍历数组。因为前边的元素可能被占用了，也可能没被占用。即数组里存的是所有连接，每个元素可能被占用，也可能没被占用。而链表里存的就必定是空闲连接，每次申请一个连接，直接拿走头结点。

#### 细节：

- 操作链表时要加锁，比如获取一个连接、释放一个连接。因为链表即连接池被所有线程共享。
- 连接池中剩余的空闲连接数实际上是用信号量来维系的。
- connection_pool是数据库连接池类，它是单例懒汉模式，需要手动执行GetInstance()来获得单例。
- 该单例的实际表现形式是static connection_pool instance即c++局部静态变量。因此无需delete，程序运行结束时自然会收回。
- 在main中流程是：
  - 1.创建数据库连接池类型的单例
    - connection_pool* connPool = connection_pool::GetInstance();
  - 2.调用类内封装好的init函数，进行真正的数据库连接创建
    - connPool->init("localhost", "root", "123", "yourdb", 3306, 8);
    - 最后这个8即表明，池子里创建好8个数据库连接，等待使用。
- 获取一条数据库连接，理论上应该手动执行connection_pool里的GetConnection()函数。将一个条连接释放，还给池子，理论上应该手动执行connection_pool里的ReleaseConnection(MYSQL *conn);函数。为了避免手动申请了一个连接即执行GetConnection()，后忘记手动释放即ReleaseConnection(MYSQL *conn)，因此将获取一条连接这个过程包装成了一个类。申请一条连接，即实例化一个connectionRAII对象，构造函数connectionRAII mysqlcon(&mysql, connPool)里来自动执行GetConnection（），将得到的连接保存在对象内部数据成员一份，返回给&mysql一份。连接的释放（还给池子），即connectionRAII  mysqlcon这个对象消逝时，析构函数自动执行ReleaseConnection(MYSQL *conn);

#### 要点

- 因此：
  - 连接池的建立，由手动执行connection_pool* connPool = connection_pool::GetInstance();来做到。单例模式，保证了该类型只会有唯一的实例。懒汉模式，需要人手动执行才能建立该唯一的实例。
  - 连接池的释放（摧毁池子，即close所有的连接），由connection_pool类内的局部静态变量connection_pool instance消逝时（也就是程序结束时），自动执行析构函数释放。
  - 一条连接的申请（从空闲池里获取一个连接），实例化一个connectionRAII  mysqlcon对象来做到
  - 一条连接的释放（还给池子），由connectionRAII  mysqlcon这个对象自然消逝来做到。
- 这就是RAII的思想：“Resource Acquisition is Initialization”，“资源获取即初始化”
  - 在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定
  - RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理，智能指针是RAII最好的例子

#### 使用到的技术

- 链表（STL的list）构建池子（连接池类里的核心数据成员连接池链表）。从池子拿走一个连接即删除头结点，归还一个连接即添加至尾结点后面

  - ```c
    connection_pool的类内成员变量： list<MYSQL *> connList; //连接池
    ```

- 互斥锁，操作链表时要加锁，比如获取一个连接、释放一个连接。因为链表即连接池是被所有线程共享的。

  - ```c
    connection_pool的类内成员变量：connection_pool::locker lock; //互斥锁
    ```

- 信号量，用来表示空闲连接。它理论上应该跟链表的实时长度是一致的，因为在链表里的肯定是可用的连接。

  - 当申请一条连接时，信号量不够了，即没有可用连接了，那就得阻塞在信号量申请即`reserve.wait();`那儿，直到有资源可用

  - ```c
    connection_pool的类内成员变量：connection_pool::sem reserve; //信号量,它的值其实就是当前空闲的连接数。
    ```

- 单例懒汉模式：单例指连接池这个类，只能有唯一一个实例。懒汉是指这个连接池类，在使用前，需要人工执行`connection_pool* connPool = connection_pool::GetInstance();`来创建这个唯一的连接池类实例。单例懒汉模式是使用C++局部静态变量来实现的，C++11规定了local static变量在多线程条件下的初始化行为，要求编译器保证局部静态变量的线程安全性。

  - ```c
    //单例模式。
    //懒汉是指实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。
    //在第一次使用这个单例类之前，要手动调用下边这个函数去创建单例。
    connection_pool的类内成员函数：
    connection_pool* connection_pool::GetInstance(){
        static connection_pool instance;//c++局部静态变量。C++11规定了local static变量在多线程条件下的初始化行为，要求编译器保证局部静态变量的线程安全性。
        return &instance;
    }
    ```
    
  - 私有化单例类的构造函数，以防止外界创建单例类的对象；C++局部静态变量指向类的唯一实例，并用一个公有的静态方法（成员函数）获取该实例

- RAII思想：将获取一条数据库连接和将该连接归还给池子这两个操作包装成了，connectionRAII类的实例化和自动析构，即构造函数和析构函数。将一个资源（一条数据库连接）和一个对象（connectionRAII类的一个实例）的生命周期绑定。

  - connectionRAII类可不是单例模式，它肯定可以有多个实例。连接池类connection_pool才是单例模式。

- CGI？暂时没看出来有CGI

### 2.线程池

#### 半同步/半反应堆模式（半同步半异步是指并发模式，半反应堆是指事件处理模式）

最普通的半同步/半异步模式（只说半同步半异步的并发模式，不讲事件处理模式）

> - 主线程充当异步线程，没说监听什么事件。工作线程是同步线程，没说监听什么事件。
> - 主线程监听到客户请求（可能是监听socket上的连接请求，也可能是连接socket上的其他客户请求）后，将其封装为请求对象并插入请求队列中。
> - 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权。
> - 重点：不论半同步/半反应堆也好，他们肯定都统统属于半同步/半异步模式。因为半同步/半异步模式仅仅是并发模式，并发模式配合上事件处理模式，才有了半同步/半反应堆。

半同步/半反应堆工作流程（以Reactor模式为例。即半同步半异步的并发模式+Reactor事件处理模式）

> - 主线程充当异步线程，负责监听所有socket（监听socket和连接socket）上的事件。工作线程是同步线程，不监听任何socket上的事件。
> - 如果监听socket上有可读事件发生，即有新请求到来，主线程接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。
> - 如果连接socket上有读写事件发生，即有新的客户请求（当然不是请求连接）或者有数据要发送至客户端。主线程就将该连接socket插入请求队列中。
> - 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权。
> - 重点：主线程负责监听所有socket（监听socket和连接socket）上的事件。主线程插入请求队列中的任务是就绪的连接socket（不是完成的），工作线程要自己从socket上读取客户请求和往socket写入服务器应答。

半同步/半反应堆工作流程（以Proactor模式为例。即半同步半异步的并发模式+Proactor事件处理模式）

> - 主线程充当异步线程，负责监听所有socket（监听socket和连接socket）上的事件。工作线程是同步线程，不监听任何socket上的事件。
> - 如果监听socket上有可读事件发生，若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。
> - 如果连接socket上有读写事件发生，即有新的客户请求（当然不是请求连接）或者有数据要发送至客户端。主线程从socket上接收数据，并将数据封装成请求对象（或者叫任务对象）插入到请求队列中
> - 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权。不同的是工作线程从请求队列中取得任务对象之后，即可直接处理之，而无需自己去socket上读数据或者往socket写入数据
> - 重点：主线程负责监听所有socket（监听socket和连接socket）上的事件。主线程插入请求队列中的任务是已经从连接socket上读写好的数据封装成的请求对象（任务对象），工作线程可直接处理之，而无需自己去socket上读数据或者往socket写入数据。

高效的半同步/半异步模式（其实是双异步）

> - 主线程还是异步线程，但是只管理监听socket。工作线程也是异步模式，连接socket由工作线程来管理。
> - 如果监听socket上有可读事件发生，即有新请求到来，主线程接受之以得到新的连接socket，并将该socket连接直接派发给某个工作线程来管理。此后该连接socket上的任何IO操作都由被选中的工作线程来处理，直至客户关闭连接。
>   - 主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，就把该新连接socket上的读写事件注册到自己的epoll内核事件表中。
> - 重点：主线程只负责监听socket上的读写事件。工作线程负责连接socket上的读写事件。

#### 细节

- pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为`(void *)`,若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数`(void*)`不能匹配，不能通过编译。静态成员函数就没有这个问题，里面没有this指针。
- 线程的释放：是靠my_stop标志，让线程执行的worker函数（其实是run函数）打破while循环，自然结束而释放的。而不是靠`delete[] my_threads;`，这只是把数组删了，其实只是把获取每个子线程的方法（即pthread_t）删了，这个数组删了，就无法获得每个子线程了。结束子线程是靠将my_stop设置为true，让子线程自然执行完毕而结束子线程的。而不是靠这个delete[]。
  - 原理是：脱离线程在退出时（我们让它自然退出）将自行释放其占用的系统资源，而无需人工结束线程。
  - 因此并不会使用`pthread_join`或者`pthread_cancel`
- 因为用的是半同步半反应堆（Reactor）模式，因此主线程就是异步线程。而线程池中的都是工作线程（同步线程）
- sem my_queuestat其实是信号量，它代表了请求队列上有多少待处理任务。
- locker my_queuelocker这个互斥锁是保护请求队列（链表）的互斥锁。线程池不需要保护。
  - 线程池里每个线程都一直在忙碌着做自己的事（也可能是在阻塞等待），没有拿取一个线程和归还线程的操作。从创建线程起，每个线程都在忙碌的工作着（通过信号量my_queuestat来竞争【请求队列中的待处理任务】）。
  - 备注：连接池有拿去一个连接和释放一个连接至连接池的操作。线程池并没有。
- 按原作者写法，子线程`while(!my_stop){}`。在请求队列为空时，关闭服务器，设置my_stop=true。这根本就不能是线程池各个子线程执行完毕，因为子线程会阻塞在 `my_queuestat.wait();`。这样的情况下，子线程退出并不是因为顺利执行完毕，自行退出，而是进程被关闭了，强制收回，这显然不好，因为线程可能还没有做完手中的活儿，就被强制退出了。
  - 因此我加了改进方案，`thread_pool<T>::~thread_pool(){}`即线程池析构函数里。（这个析构函数是会被delete调用的，线程池对象是new出来的）。在析构函数里，先再往请求队列上加入THREAD_NUMBER个空请求（我称之为冲刷队列的操作），以保证每个子线程可以从`my_queuestat.wait();`脱离阻塞态，顺利进入下一轮while时打破循环，顺利使得线程执行完毕自然退出。
    - 我除了在析构函数里加入了冲刷队列的操作，还加入了`pthread_join(my_threads[i],&res);`等待线程池中各个子线程退出，才会从析构函数返回。即delete threadPool;这个操作会阻塞一会儿，直到所有子线程退出。
  - 如果服务器要关闭时，请求队列里还有大量请求，那么加入THREAD_NUMBER个空请求也不会有问题，即使请求队列满了，没有把空请求加进去也没有关系。因为请求队列里还有大量请求时，子线程肯定不会阻塞在`my_queuestat.wait();`，每个子线程忙完当前的任务，进入下一轮while时，便会由于my_stop=true而打破循环，顺利使得线程执行完毕自然退出。
- 原作者把线程池中的各个子线程都设置为了脱离线程，即`// ret=pthread_detach(my_threads[i]);//设置该线程为脱离线程`。**我把各个子线程设置为了可回收线程，即主线程会pthread_join各个子线程，以等待各个子线程顺利退出。**

#### 用到的技术

- 模板类（线程池类）

  - ```c
    template<class T> 
    class thread_pool{}
    ```

  - 线程池类，定义为模板类是为了代码复用。模板参数T是任务类。T即往请求队列上放的任务类型。可以是int类型，可以是http_conn类型，任意。只要你把线程池中每个工作线程真正运行的函数run（）写对，能处理各个任务类就行（当然，我写的run肯定是针对着http_conn来写的。并没有考虑其他的任务类型）。

  - 该模板类对于T类型的使用，几乎仅仅在

    - ```
      template<class T>
      void thread_pool<T>::run(){}
      ```

    - 中。比如T是http_conn类，run函数里会直接使用

    - ```c
      T *request = m_workqueue.front();
       request->process();//这个process函数显然是http_conn类专有的
      ```

- 异常

  - ```c
        //-------------创建线程池--------------------
        thread_pool<int>* threadPool = nullptr;//在try块里声明的新变量，一出try块儿就消亡了。所以得new
        try{
            threadPool=new thread_pool<int>(connPool,THREAD_NUMBER,MAX_REQUESTS_IN_REQUESQUEUE);
        }catch(exception &e){
            cout << "创建线程池时发生异常: " << e.what() << endl;
            return 1;
        }catch(...)//捕获其余任何异常
        {
            cout << "创建线程池时发生unknown异常" << endl;
            return 1;//直接进程退出，什么资源都释放了
        }
    ```

  - 线程池类的构造函数中可能抛出std::exception()类型的异常。可能的错误类型有：【"thread_number或者max_requests参数异常"】、【("线程池数组分配内存异常")】、【pthread_create时创建第i个线程时创建发生异常】。然后就在构造函数中人工throw异常。在main中构建线程池时来try catch捕获异常

- 数组（线程池类里的核心数据成员线程池数组）

  - `template<class T> pthread_t *thread_pool<T>::my_threads//描述线程池的数组，其大小为my_thread_number`
  - 注意，线程池数组中包含THREAD_NUMBER个元素，每个元素对应一个线程的ID，即整型pthread_t 
  - 线程池是数组，跟连接池链表不一样。因为我构建的线程池没有【从线程池取一个线程和往线程池归还一个线程】这样的操作。而数据库连接池有【从连接池池取一个连接和往连接池归还一个连接】这样的操作，因此数据库连接池必须用链表，以方便的取出和加入。
  - 总结：连接池和线程池的区别
    - 连接池时链表。线程池是数组。
    - 数据库连接池有【从连接池池取一个连接和往连接池归还一个连接】这样的操作，用链表这种数据结构更合适。线程池没有【从线程池取一个线程和往线程池归还一个线程】这样的操作，用数组更合适。
    - 思考：为什么线程池没有【从线程池取一个线程和往线程池归还一个线程】这样的操作呢？因为线程池里的线程，都永远是“忙碌”状态，就没有空闲的。
    - 连接池里的的都是空闲连接，忙碌的连接已经被从链表中删除出队了。而线程池里的线程，都永远是“忙碌”状态，因为使用了信号量wait机制，让他们阻塞在代表“请求队列中任务数目”的信号量上（或者说叫每个线程都睡眠在请求队列上），线程池中的所有线程会自动地去竞争（通过信号量wait机制）请求队列上每个任务的接管权。

- 链表（请求队列或者说叫工作队列）

  - `std::list<T *> my_workqueue; //请求队列`
  - 虽然明面上叫请求队列，我还是用链表来实现（stl的链表类里有队列的所有操作啊！跟队列没啥区别）。
  - 请求队列里存放的元素其实就是需要线程池中的子线程来处理的一个一个的任务。
  -  在主线程中通过`threadPool->append(xxx);`的操作来往线程池对象里维护的请求队列添加任务。

- 互斥锁（用来保护请求队列，即链表。不是用来保护线程池即数组的，线程池里每个线程都一直在忙碌着做自己的事（也可能是在阻塞等待），没有拿取和归还线程的操作）

  - `locker my_queuelocker;//保护请求队列（链表）的互斥锁。线程池不需要保护`
  - 互斥锁是用来保护请求队列，即链表的。而不是用来保护线程池即数组的，线程池里每个线程都一直在忙碌着做自己的事（也可能是在阻塞等待），没有拿取和归还线程的操作，因此线程池数组根本就不用保护。
  - 反而是请求队列，主线程每次往请求队列里添加任务`threadPool->append(xxx);`。或者子线程从请求队列上取走任务，凡是涉及到请求队列上元素变动的，都需要加锁。理由也很简单，请求队列是被所有线程共享的。不论主线程、子线程来操作它，都应该加锁。

- 信号量（代表请求队列中任务的数量）

  - `sem my_queuestat;//信号量，是否有任务需要处理。也代表了请求队列中有多少任务需要处理 `
  - 线程池里的线程，都永远是“忙碌”状态，因为使用了信号量wait机制，让他们阻塞在代表“请求队列中任务数目”的信号量上（或者说叫每个线程都睡眠在请求队列上），线程池中的所有线程会自动地去竞争（通过信号量wait机制）请求队列上每个任务的接管权。

- 线程的pthread_create、pthread_join、pthread_detach

  - 在线程池类的构造函数中，`int ret=pthread_create(&(my_threads[i]),nullptr,worker,this);`创建每个子线程
  - 在线程池类的析构函数中，设置线程退出标志threadPool->my_stop来使得各个子线程打破while循环，自然退出。析构函数中设置my_stop为false后，pthread_join各个子线程，等待他们顺利退出。
  - pthread_detach没有使用，跟pthread_join是完全相反的两码事。pthread_detach设置的线程叫脱离线程，脱离线程不可以被pthread_join，只有可回收线程才能被pthread_join。

- 冲刷请求队列机制

  - 如果在请求队列为空时，我去停止服务器。想要在线程池类的析构函数中，设置线程退出标志threadPool->my_stop来使得各个子线程打破while循环，自然退出。这是不可能的。因为各个子线程都阻塞在信号量的获取`my_queuestat.wait();`上了
  - 因此我在线程池类的析构函数中，设置线程退出标志threadPool->my_stop为true之后，往请求队列上又放置了THREAD_NUMBER个空请求，以保证各个子线程顺利打破while，自然执行结束

- 半同步/半反应堆模式（半同步半异步是指并发模式，半反应堆是指事件处理模式）

  - 线程充当异步线程，负责监听所有socket（监听socket和连接socket）上的事件。工作线程是同步线程，不监听任何socket上的事件。
  - 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权。
  - 我写的这个线程池类，可以是半同步/半反应堆（Reactor），也可以是半同步/半反应堆（Proactor）。关键就在于模板类中的任务类型T
    - Reactor：主线程插入请求队列中的任务，即T类型对象是就绪的连接socket（不是完成的），工作线程要自己从socket上读取客户请求和往socket写入服务器应答。
    - Proactor：主线程插入请求队列中的任务，即T类型对象是已经从连接socket上读写好的数据封装成的请求对象（任务对象），工作线程可直接处理之，而无需自己去socket上读数据或者往socket写入数据。

### 3.日志系统--阻塞队列类

#### 简介

- **`日志`**，由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。
  - **`同步日志`**，日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。
  - **`异步日志`**，将所写的日志内容先存入**阻塞队列**，写线程从**阻塞队列**中取出内容，写入日志。

- 阻塞队列类中封装了生产者-消费者模型，其中push成员是生产者，pop成员是消费者。
- 阻塞队列中，~~使用了循环数组实现了队列~~，作为两者共享缓冲区，当然了，队列也可以使用STL中的queue。
  - 我是用的是list
- **阻塞队列实际就是在队列的基础上加上了阻塞操作，当队列为空时，出队操作就会被阻塞，因为队列里没有数据，直到队列里有数据之后才能返回；当队列满的时候，入队操作就会被阻塞，直到队列中有空闲的空间时再执行入队操作。**我们可以用阻塞队列很容易的实现一个”生产者-消费者“模型，这样我们可以有效的控制生产和消费的速度。当生产者生产的过快时，队列很快就满了，这个时候生产者就阻塞等待，直到消费者消费了，生产者才会被唤醒继续生产。反之消费者消费过快时也同样被阻塞。不仅如此，我们还可以通过调整生产者和消费者的个数，来实现生产和消费的供需平衡。

#### 用到的技术

- 链表（阻塞队列主体）
  - `list<T> my_blockqueue`
- 互斥锁（访问链表要加锁）
  - 用来保护队列` list<T> my_blockqueue`的多线程安全
- 条件变量（生产者消费者）
  - 当消费者消费过快时，队列很快就空了，这个时候消费者就阻塞等待（pop函数里阻塞等待my_cond.wait或者等待超时后返回my_cond.timewait），直到生产者生产了，消费者才会被唤醒继续消费
    - 在作者的实现中，只有一个条件变量。就是消费者就阻塞等待，被生产者使用条件变量唤醒，继续消费。
  - 当生产者生产的过快时，队列很快就满了，这个时候~~生产者就阻塞等待~~（生产者就添加失败，即push函数直接返回false），~~直到消费者消费了，生产者才会被唤醒继续生产~~。
    - 在作者的实现中，只有一个条件变量。并没有生产者被阻塞，然后被消费者唤醒继续生产的功能。
    - 也就是只有单向阻塞。消费者从空队列里取东西会阻塞，生产者往满队列里放东西会直接返回false，而不会阻塞。
- 生产者消费者模式
  - 生产者线程执行：`block_queue<T>::push`。线程安全地往阻塞队列里放东西。
  - 消费者线程执行：`block_queue<T>::pop`。线程安全地从阻塞队列里取东西。
- 备注：
  - 什么叫阻塞队列？就是普通的队列加上了阻塞操作。
    - 当队列为空时，从队列中获取元素的线程将会被挂起（阻塞）；当队列是满时，往队列里添加元素的线程将会挂起（阻塞）。
  - 阻塞操作怎么实现的？用条件变量。
    - 当队列为空时，消费者还要从队列取东西（pop），那么消费者线程就会阻塞在条件变量上（`my_cond.wait(my_mutex.get());`）。当生产者又生产了新的东西放入（push）队列时（队列上有东西了，可以消费了，但是所有消费者线程都在阻塞着呢，所以必须得唤醒消费者），所以就会执行`my_cond.broadcast()`，唤醒所有阻塞在条件变量my_cond上的消费者线程来从队列取东西
    - ~~当队列满了时，生产者还要往队列里放东西（push），那么生产者线程就会阻塞在另一个条件变量`（my_cond2.wait(my_mutex.get());`上。当消费者从队列取走（pop）一个东西时（队列不满了，可以往队列上放东西了，但是所以生产者线程都在阻塞着呢，所以必须得唤醒生产），所以就会执行`my_cond2.broadcast()`，唤醒所有阻塞在条件变量my_cond2上的生产者线程往队列放东西~~
      - （没实现这个功能，讲道理应该实现的）

### 4.日志系统--日志类

#### 简介

#### 用到的技术

- 单例模式
- 

