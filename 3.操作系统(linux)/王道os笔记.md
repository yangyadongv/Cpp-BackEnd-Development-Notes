# 0.总结

## 1.操作系统

- 操作系统就是个管家，用户通过操作系统间接管理计算机硬件、软件。
- 操作系统向上为用户提供了 命令接口（比如在shell中的ls命令）、系统调用（比如封装在printf函数中的write函数，write函数就是系统调用，它对应的内核程序是sys_write）。
- CPU在执行内核程序的时候，就是内核态。在执行用户程序的时候就是用户态。
- 可以在内存中看做上下两个部分，内核程序和用户程序是分开放的，内核程序放在核心段，用户程序放在用户段
- 只能通过中断进入内核程序，比如通过int 0x80中断进行系统调用，系统调用将会执行操作系统的内核程序。比如sys_write往磁盘或者是往显存写数据。
- 用户态线程就是执行在用户态下，它当然可以进行系统调用进去内核态执行，然后再回来。只是用户态线程的线程调度切换是程序员自己把控的，在用户态下切换调度。
- 核心态线程，线程的调度切换时系统自动进行的。切换发生在核心套。比如执行系统调用write后，进入内核程序，启动IO，系统就自动调度到下个线程了。

## 2.进程

- 进程是资源分配的基本单位，线程是CPU调度的基本单位。同一个进程的线程共享资源

- 线程的切换是通过：状态+PCB+队列机制实现的。

- **进程互斥**就是，比如进程1正在往一张纸打印，打印了一半，突然CPU有事，它没操作完，CPU被调度走了。这时另一个进程2来了，它也想用打印机打印，如果我同意了，那么会乱套的。有一半是进程1写的，另一半是进程2的。所以在进程1彻底打完之前，我都不允许其他进程打印。其他进程来了以后，只能直接阻塞，直到进程1打完释放了资源，然后wakeup一个等待使用打印机的进程到就绪队列中。

- 进程同步就是比如进程2的代码5需要进程1的代码2的结果。那么进程2执行完代码4之后，必须得等待进程1执行完代码2。在此之前，进程2只能阻塞等待。

  - 

  ```c++
  P1(){
      代码1;
      代码2;
      代码3;
  }
  P2(){
      代码4;
      代码5;
      代码6;
  }
  ```

- 实现进程同步和进程互斥一般都用信号量机制和PV操作实现。信号量看做就是一个数字，当然一般还包括一个相应的阻塞队列。信号量代表某种资源的数目。比如信号量此时=2，意味着，还有两台打印机可以使用。信号量=0，意味着，资源全分配出去了，没资源了。信号量=-3，意味着，有3个进程在等着使用打印机呢。

- 管程就是把信号量机制实现的进程互斥、进程同步进行了封装。程序员在写代码的时候，一句话就可以，而不用自己写P、V操作。管程实现的进程互斥是通过编译器实现的，进程同步是通过管程的内部代码实现的。

## 3.内存

虚拟内存是分段连续分配的，物理内存是分页离散分配的。

# 1.第一章简介

## 1.1操作系统的概念、功能

### 1.操作系统的概念

![G2FrE8.png](https://s1.ax1x.com/2020/04/07/G2FrE8.png)

### 2.管理系统资源

![G2EoUf.png](https://s1.ax1x.com/2020/04/07/G2EoUf.png)

### 3.总结

**联机命令接口**：即交互式命令接口(比如cmd里边的命令），用户说一句，系统做一局

**脱机命令接口**：批处理命令接口(比如 .bat文件)，用户写了一堆，系统跟着做一堆

**程序接口**：可以在程序中进行**系统调用**来使用程序接口。普通用户不能直接使用程序接口，只能通过程
序代码**间接**使用。比如：写C语言“Hello world”程序时，在printf 函数的底层就使用到了操作系统提
供的显式相关的“系统调用”。（一些教材中系统调用也叫作广义指令）

**扩充机器**：通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机。（类比汽车：发动机——只会转；轮胎——只会滚；在原始的硬件机器上覆盖一层传动系统——让发动机带着轮子转——使原始的硬件机器得到拓展。操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能。普通用户无需关心这些硬件在底层是怎么组织起来工作的，只需直接使用操作系统提供的接口即可）

![G2kfRH.png](https://s1.ax1x.com/2020/04/07/G2kfRH.png)



## 1.2操作系统的特征

### 1.并发

**并发**：指两个或多个事件在**同一时间间隔**内发生。这些事件**宏观上是同时发生**的，但**微观上是交替发生**的。

**并行**：指两个或多个事件在**同一时刻**同时发生。

**单核CPU**同一时刻只能执行一个程序，各个程序**只能并发**地执行
**多核CPU**同一时刻可以同时执行多个程序，多个程序**可以并行**地执行(**当然也有并发**)

例如：对于4核CPU来说，只要有4个以上的程序需要“同时”运行，那么并发性依然是必不可少的，因此并发性是操作系统一个最基本的特性

### 2.共享

**共享**即资源共享，是指系统中的**资源**可供内存中**多个并发执行的进程共同使用**。

两种资源共享的方式：

- 互斥共享方式：
  - 系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。（比如摄像头）
- （宏观）同时共享方式
  - 使用QQ发送文件A，同时使用微信发送文件B。**宏观**上看，两边都在**同时**读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。**微观**上看，两个进程是**交替**着访问硬盘的。
  - 扬声器，放歌又放游戏音效，这就是**宏观**上**同时**，**微观**上也是**同时**地。

### 3.虚拟

**虚拟**是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。

虚拟技术：

- 空分复用技术（如虚拟存储器技术）
  - 比如：一个RAM实物只有4G，而实际上电脑利用（用户感受到的）的内存远超过4G。换句话说，可以开超过4G的后台应用程序。
- 时分复用技术（如虚拟处理器）
  - 虚拟技术中的“时分复用技术”。微观上处理机在各个微小的时间段内交替着为各个进程服务。
  - 所以，就算是单核cpu，也可以同时运行多个程序。实际上只有一个单核cpu，但是用户看起来似乎有很多个cpu在工作。

### 4.异步

**异步**是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进**程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进**，这就是进程的异步性。

由于**并发运行的程序**会**争抢**着使用**系统资源**，而系统中的资源有限，因此**进程的执行不是一贯到底**的，而是走走停停的，以不可预知的速度向前推进。

### 5.总结

![G2euge.png](https://s1.ax1x.com/2020/04/07/G2euge.png)

## 1.3操作系统的发展与分类

![image.png](https://i.loli.net/2020/04/07/JSjxLvZGhWNeH2R.png)

## 1.4操作系统的运行机制与体系结构

![G2BZIP.png](https://s1.ax1x.com/2020/04/07/G2BZIP.png)



### 1.运行机制

**两种指令：**

- **特权指令**：不允许用户程序使用。比如：内存清零指令。
- **非特权指令**：用户可以使用的。比如：普通的运算指令，加减乘除等。

执行指令时，CPU就会判断一下， 当前是否允许执行特权指令。那么**CPU如何判断当前是否可以执行特权指令呢**?

**两种处理器状态：**（一般是用程序状态字寄存器（PSW）中的某标志位来标识的，就0和1）

- **核心态（**管态）：特权指令、非特权指令都可执行
- **用户态**（目态）：此时只能执行非特权指令

**两种程序：**

- **内核程序**：操作系统的内核是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。
- **应用程序**：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。

### 2.操作系统内核

![image.png](https://i.loli.net/2020/04/07/T65Q4PfVyjihOzu.png)

**原子性**：这个程序要么不执行， 要么刚开始执行就得执行到结束，一气呵成，不能中断。

![G7OOpD.png](https://s1.ax1x.com/2020/04/11/G7OOpD.png)

### 3.操作系统的体系结构（两种划分）

![G7XmBn.png](https://s1.ax1x.com/2020/04/11/G7XmBn.png)

![G20Hv4.png](https://s1.ax1x.com/2020/04/07/G20Hv4.png)

两种操作系统体系结构的划分：

- 大内核：内核包含着**进程管理、存储器管理、设备管理等**功能，和**基础功能，例如时钟管理、中断处理、原语。**(比如：Linux、Unix)
- 微内核：**内核只包含有基础功能，例如时钟管理、中断处理、原语。**（比如windows NT)

## 1.5中断和异常

### 1.中断机制的诞生

本质：发生中断就意味着需要操作系统介入，开展管理工作。

### 2.中断的概念和作用

![G2cvOU.png](https://s1.ax1x.com/2020/04/07/G2cvOU.png)

1. 当中断发生时，CPU立即进入核心态
2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同的中断信号，会进行不同的处理
4. CPU从**用户态切换到核心态**，是由中断实现的，并且中断是唯一途径。反过来，**核心态到用户态**，是通过执行一条特权指令，将程序状态字(PSW)的标志位设置为“用户态”；

### 3.中断的分类

![G2c4OS.png](https://s1.ax1x.com/2020/04/07/G2c4OS.png)

### 4.外中断的处理过程

![G2g7nO.png](https://s1.ax1x.com/2020/04/07/G2g7nO.png)

### 5.总结

![G221UJ.png](https://s1.ax1x.com/2020/04/07/G221UJ.png)

## 1.6系统调用

### 1.什么是系统调用

**操作系统**作为用户和计算机硬件之间的接口，需要**向上提供**一些简单易用的**服务**。主要包括**命令接口(比如cmd里的命令)**和**程序接口**。其中，**程序接口**由一组**系统调用**组成。

![GTEA6P.png](https://s1.ax1x.com/2020/04/10/GTEA6P.png)

**“系统调用”**是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，**应用程序可以通过系统调用来请求获得操作系统内核的服务**

### 2.系统调用与库函数的区别

系统调用的相关处理在**核心态**进行

![GTZQs0.png](https://s1.ax1x.com/2020/04/10/GTZQs0.png)

### 3.为什么系统调用是必须的

![GTeFp9.png](https://s1.ax1x.com/2020/04/10/GTeFp9.png)

### 4.什么功能要用到系统调用（按功能分类）

应用程序通过**系统调用**请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此**凡是与共享资源有关的操作**（如存储分配、I/O操作、文件管理等），**都必须通过系统调用的方式向操作系统内核提出服务请求**，由操作系统内核代为完成。这样可以**保证系统的稳定性和安全性**，防止用户进行非法操作。

![G7oZ8A.png](https://s1.ax1x.com/2020/04/11/G7oZ8A.png)

### 5.系统调用的过程

![G7bo0P.png](https://s1.ax1x.com/2020/04/11/G7bo0P.png)

### 6.总结

![G7qB9g.png](https://s1.ax1x.com/2020/04/11/G7qB9g.png)

# 2.第二章CPU

## 1.进程

### 1.1进程的定义、组成、组织方式、特征

#### 1.进程的定义

**程序段、数据段、PCB**三部分组成了**进程实体（进程映像）**。一般情况下，我们把进程实体就简称为进程，例如所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。注意：**PCB是进程存在的唯一标志**。

程序：是**静态**的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。

进程：是**动态**的，是程序的一次执行过程（同一个程序多次执行会对应多个进程）。或者说是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

注意：本质上来讲，**进程实体**是**静态**的，**进程**是**动态**的。但是，除非题目专门考察二者区别，**一般将进程实体就认为是进程**。因此也可以说是进程由程序段、数据段、PCB三部分组成。

#### 2.进程的组成

进程（指进程实体）由程序段、数据段、PCB三部分组成。

![GHp4Cq.png](https://s1.ax1x.com/2020/04/11/GHp4Cq.png)

**PCB（Process Control Block）**:即进程控制块，它是一种数据结构。操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中。

![GH93Is.png](https://s1.ax1x.com/2020/04/11/GH93Is.png)

![GH9RsO.png](https://s1.ax1x.com/2020/04/11/GH9RsO.png)

#### 3.进程的组织

**进程的组成（上一节）**：讨论的是**一个进程内部**由哪些部分构成的问题。

**进程的组织（本节）**：则是讨论**多个进程之间**的组织方式问题。

![GHCG0e.png](https://s1.ax1x.com/2020/04/11/GHCG0e.png)

##### 链接方式：

![GHCjc6.png](https://s1.ax1x.com/2020/04/11/GHCjc6.png)

##### 索引方式：

![GHPCAH.png](https://s1.ax1x.com/2020/04/11/GHPCAH.png)

#### 4.进程的特征

![GHPQ4s.png](https://s1.ax1x.com/2020/04/11/GHPQ4s.png)

#### 5.总结

![GHa21s.png](https://s1.ax1x.com/2020/04/11/GHa21s.png)

### 1.2进程的状态与转换

#### 1.进程的状态--三种基本状态+2种另外状态

进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。

![GHwGzd.png](https://s1.ax1x.com/2020/04/11/GHwGzd.png)

![GH0ATf.png](https://s1.ax1x.com/2020/04/11/GH0ATf.png)

#### 2.进程状态间的转换

![GHBVD1.png](https://s1.ax1x.com/2020/04/11/GHBVD1.png)

#### 3.总结

![GHWSsO.png](https://s1.ax1x.com/2020/04/11/GHWSsO.png)

### 1.3进程控制

#### 1.什么是进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现
进程状态转换等功能。

简化理解：反正**进程控制就是要实现进程状态转换**

[![GHWySx.png](https://s1.ax1x.com/2020/04/11/GHWySx.png)](https://imgchr.com/i/GHWySx)

#### 2.如何实现进程控制

**回顾一下进程组织问题**，即多个进程之间的组织方式

![GHfN9I.png](https://s1.ax1x.com/2020/04/11/GHfN9I.png)

**详细一点**就是下边：

![GHhMPs.png](https://s1.ax1x.com/2020/04/11/GHhMPs.png)

为了防止 PCB所在的队列，与PCB中储存的状态标志位不同（例如，当前PCB正处在运行中，主动发出系统调用请求（即陷入指令），等待磁盘读取结果。那么它将被放置到阻塞队列中。如果把它放到了阻塞队列，而忘记修改它的PCB中储存的状态标志位，那么将出现所处队列（比如正在阻塞队列）与PCB中数据标志的状态（标识是运行状态）不匹配的情况。这是非常危险的事情。）为了防止这种情况的出现，**需要“原语”实现。**

用原语实现进程控制。原语的特点是执行期间**不允许中断**，只能一气呵成。这种不可被中断的操作即**原子操作**。
原语采用“关中断指令”和“开中断指令”实现。

也就是说我在进行进程状态切换的时候，是原子的，不允许被打断的。这是为了保证进程所处队列与进程标志严格保持一致。

![GH5Fnf.png](https://s1.ax1x.com/2020/04/11/GH5Fnf.png)

#### 3.进程控制相关的原语

**具体地：进程控制时（进程状态切换时）的原语，到底做了哪些事：(三类事）**

**这相当于是所有类型的进程切换（例如创建态到就绪态，就绪态到阻塞态等等各种状态切换）的共性**

学习技巧：进程控制会导致进程状态的转换。无论哪个进程控制原语，要做的无非三类事情：
1. 更新PCB中的信息
    a. 所有的进程控制原语一定都会修改进程状态标志
    b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
    c. 某进程开始运行前必然要恢复期运行环境

2. 将PCB插入合适的队列

3. 分配/回收资源

   

##### 进程的创建（从无到创建到就绪）

进程创建时需要原语。即从无-->创建态，从创建态-->就绪态，这都是状态切换，需要原语。

创建时做了什么事呢？

![GHTFnx.png](https://s1.ax1x.com/2020/04/11/GHTFnx.png)

##### 进程的终止

![GH7mZV.png](https://s1.ax1x.com/2020/04/11/GH7mZV.png)

##### 进程的阻塞和唤醒

![GH7diD.png](https://s1.ax1x.com/2020/04/11/GH7diD.png)

##### 进程的切换

![GHHW0x.png](https://s1.ax1x.com/2020/04/11/GHHW0x.png)

#### 4.总结

![GHLiT0.png](https://s1.ax1x.com/2020/04/11/GHLiT0.png)

### 1.4进程通信

#### 1.进程通信概念

顾名思义，**进程通信就是指进程之间的信息交换**。
进程是分配系统资源的单位（包括内存地址空间），因此**各进程**拥有的**内存地址空间相互独立**。

![GHx1zT.png](https://s1.ax1x.com/2020/04/11/GHx1zT.png)

#### 2.共享存储

![GHzWB4.png](https://s1.ax1x.com/2020/04/11/GHzWB4.png)

#### 3.消息传递

消息传递是值：进程间的数据交换以**格式化的消息**（Message）为单位。进程通过操作系统提供的“发送消息/接收
消息”两个**原语**进行数据交换。

**格式化的消息：**包括消息头和消息体。

**直接通信方式**：就是将（格式化的）消息直接挂到接收进程的消息缓冲队列上。（比如进程1通过“发送消息”原语发送消息，该原语将消息挂到进程二的消息缓冲队列尾上。进程二又会通过接受消息原语来将消息一个个取走处理）

**间接通信方式：**消息会发送到中间实体（信箱）中，	因此也称为“信箱通信方式”。（比如进程1通过发送原语，将消息发送至信箱，进程2通过接收原语，去信箱中取出消息。消息谁发送，发送给谁都会包含在消息头中，不用担心取错的问题）

![Gb9Ru8.png](https://s1.ax1x.com/2020/04/11/Gb9Ru8.png)

#### 4.管道通信

![GbSWxf.png](https://s1.ax1x.com/2020/04/11/GbSWxf.png)

#### 5.总结

![GbCZUH.png](https://s1.ax1x.com/2020/04/11/GbCZUH.png)

### 1.5线程概念和多线程模型

#### 1.什么是线程

- 首先说进程，在还**没有进程的时候**，系统中各个程序只能串行执行。想边聊qq，边听音乐，是不可以的。
- **引入进程之后**，可以边聊qq，边听音乐了。
- 但是qq可以一边跟人视频，一边跟人文字聊天，还可以一边传输文件。进程是程序的一次执行，但是这些功能显然不可能是由一个程序顺序处理就能实现的。
- 有的进程需要“（宏观上）同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。
- 可以把线程理解为“轻量级进程”
- **线程**是一个基本的CPU执行单元，也是程序执行流的最小单位。
- 引入线程之后，不仅是**进程之间可以并**发，**进程内的各线程之间也可以并发**，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如同时 qq视频、文字聊天、传文件）
- 有了线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的，而不是分配给线程。**从属于同一进程**的**各个线程共享进程的资源**）

#### 2.引入线程机制后，有什么变化

![Gb4l5Q.png](https://s1.ax1x.com/2020/04/11/Gb4l5Q.png)

#### 3.线程有哪些重要的属性

![Gb52Ss.png](https://s1.ax1x.com/2020/04/11/Gb52Ss.png)

#### 4.线程的实现方式

有的操作系统支持用户级线程，有的支持内核级线程。有的都支持。

##### 用户级线程

![Gb7Q9e.png](https://s1.ax1x.com/2020/04/11/Gb7Q9e.png)

**对于这种情况，也就是说，就算在4核CPU上运行，也最多只有一个用户级线程在运行。(无法做到两个用户级线程并行（也就是狭义上的同时运行）)**

##### 内核级线程

![GbH2qI.png](https://s1.ax1x.com/2020/04/11/GbH2qI.png)

##### 组合起来

![GbLGRS.png](https://s1.ax1x.com/2020/04/11/GbLGRS.png)

#### 5.多线程模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引
出了“多线程模型”问题。

##### 多对一模型

![GbOtfK.png](https://s1.ax1x.com/2020/04/11/GbOtfK.png)

##### 一对一模型

![GbOXX4.png](https://s1.ax1x.com/2020/04/11/GbOXX4.png)

##### 多对多模型

![GbXl38.png](https://s1.ax1x.com/2020/04/11/GbXl38.png)

#### 6.总结

![GbXv28.png](https://s1.ax1x.com/2020/04/11/GbXv28.png)

## 2.调度

### 2.1处理机调度的概念、层次

#### 1.调度的基本概念

**什么是调度?**

当有一堆任务要处理，但由于**资源有限**，这些事情没法同时处理。这就需要确定**某种规则**来**决定处理**
**这些任务的顺序**，这就是“调度”研究的问题。

**什么是处理机调度?**

在多道程序系统中，进程的数量往往是多于处理机的个数的，这样**不可能同时并行地处理各个进程**。
**处理机调度**，就是从就绪队列中**按照一定的算法选择一个进程**并**将处理机分配给它**运行，以实现进程
的并发执行。

#### 2.三个层次

##### 高级调度（外存到内存的过程，只被调入一次）

![GqkebV.png](https://s1.ax1x.com/2020/04/11/GqkebV.png)

##### 中级调度（挂起状态的进程重新调回内存，这可能被调入调出很多次）

内存中阻塞(也有可能是就绪）的进程暂时调到外存中保存，等它的运行条件具备了，再调回内存。

![GqkLIU.png](https://s1.ax1x.com/2020/04/11/GqkLIU.png)

##### 低级调度（进程调度）

![GqAIYD.png](https://s1.ax1x.com/2020/04/11/GqAIYD.png)

#### 3.三层调度的联系、对比

![GqEetU.png](https://s1.ax1x.com/2020/04/11/GqEetU.png)

#### 4.补充知识

- 暂时调到外存等待的进程状态为**挂起状态（挂起态，suspend）**
- 挂起态又可以进一步细分为**就绪挂起**、**阻塞挂起**两种状态

![GqAcl9.png](https://s1.ax1x.com/2020/04/11/GqAcl9.png)

#### 5.总结

![GqEJAK.png](https://s1.ax1x.com/2020/04/11/GqEJAK.png)

### 2.2进程调度的时机、切换与过程、方式

#### 1.时机

进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

**不能进行进程调度与切换是指：**运**行在以下3种情况时，CPU是不可以被调离走的。必须得处理完，CPU才能调离去干别的任务。**

![GqWXAe.png](https://s1.ax1x.com/2020/04/12/GqWXAe.png)

中断处理过程复杂，与硬件密切相关，所以在中断任务操作时，不允许将CPU调走。

解释一下：进程在操作系统内核程序临界区中，不能进行调度与切换。（执行普通内核程序时，还是可以调度与切换的，内核级线程不就是这样吗，切换内核栈）

![Gqf5VS.png](https://s1.ax1x.com/2020/04/12/Gqf5VS.png)

#### 2.切换与过程

![GqhJZ8.png](https://s1.ax1x.com/2020/04/12/GqhJZ8.png)

#### 3.方式

![GqfzaF.png](https://s1.ax1x.com/2020/04/12/GqfzaF.png)

#### 4.总结

![GqhaGj.png](https://s1.ax1x.com/2020/04/12/GqhaGj.png)

### 2.3调度算法的评价指标

#### 1.CPU利用率

![Gqh4Q1.png](https://s1.ax1x.com/2020/04/12/Gqh4Q1.png)

#### 2.系统吞吐量

![GOWzcR.png](https://s1.ax1x.com/2020/04/12/GOWzcR.png)

#### 3.周转时间

![GOhpGQ.png](https://s1.ax1x.com/2020/04/12/GOhpGQ.png)

为了更加体现出用户体验的区别，引入**带权周转时间**：

![GO5Oq1.png](https://s1.ax1x.com/2020/04/12/GO5Oq1.png)

#### 4.等待时间

![GOIXlQ.png](https://s1.ax1x.com/2020/04/12/GOIXlQ.png)

#### 5.响应时间

对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系
统服务、回应。
**响应时间**，指从用户**提交请求**到**首次产生响应**所用的时间。

#### 6.总结

![GOo86H.png](https://s1.ax1x.com/2020/04/12/GOo86H.png)

### 2.4FCFS、SJF、HRRN调度算法

这三个一般都不适用于交互式系统

#### 1.先来先服务(FCFS)

![GOXmFA.png](https://s1.ax1x.com/2020/04/12/GOXmFA.png)

#### 2.短作业优先（SJF）/短进程优先（SPF）

- ##### 非抢占式（一个完了才能下一个）

  - 每次调度时选择，当前已到达且运行时间最短的作业/进程。

- ##### 抢占式（这个还没完，就可以打断，先处理下一个）

  - 抢占式的短作业优先算法又称为“**最短剩余时间优先算法（SRTN）**”
  - **最短剩余时间优先**算法：每当有进程加入**就绪队列改变时就需要调度**，如果新到达的进程剩余时间比当前运行的进程**剩余时间更短**，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当**一个进程完成时也需要调度**

![GXwnNq.png](https://s1.ax1x.com/2020/04/13/GXwnNq.png)

#### 比较FCFS和SJF

![GXw0gO.png](https://s1.ax1x.com/2020/04/13/GXw0gO.png)

#### 3.高响应优先（HRRN）

![GXBxHJ.png](https://s1.ax1x.com/2020/04/13/GXBxHJ.png)

#### 4.对比总结

都既可以用于作业调度，又可用于进程调度

![GXDsrF.png](https://s1.ax1x.com/2020/04/13/GXDsrF.png)

### 2.5调度算法：时间片轮转、优先级、多级反馈队列

#### 1.时间片轮转调度算法（RR，Round-Robin）

**仅可用于进程调度，一定是抢占式的，不会导致饥饿**

时间片轮转调度算法：**轮流让就绪队列中的进程**依次执行一个时间片（每次选择都是排在就绪队列队头的进程）

- 如果**时间片太大**，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法**退化为先来先服务**调度算法，并且**会增大进程响应时间（从提交到首次响应的时间）**。因此时间片不能太大。
- 另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果**时间片太小**，会导致**进程切换过于频繁**，系统会**花大量的时间来处理进程切换**，从而导致实际用于进程执行的时间比例减少。因此时间片也不能太小（一般来说，设计时间片时要让切换进程的开销占比不超过1%）。

![GXhCc9.png](https://s1.ax1x.com/2020/04/13/GXhCc9.png)

#### 2.优先级调度算法

- 非抢占式的优先级调度算法：每次调度时选择**当前已到达**且**优先级最高**的进程。只有每次当前进程**主动放弃处理机时**才发生调度。
- 抢占式的优先级调度算法：每次调度时选择**当前已到达**且**优先级最高**的进程。当前进程主动放弃处理机时发生调度，另外，**当就绪队列发生改变时**（也就是有新的进程就绪时）也需要检查是否会发生抢占。
- 补充
  - ![GjMqHS.png](https://s1.ax1x.com/2020/04/13/GjMqHS.png)

![GjQE4J.png](https://s1.ax1x.com/2020/04/13/GjQE4J.png)

#### 3.多级反馈队列调度算法

![Gjl4yt.png](https://s1.ax1x.com/2020/04/13/Gjl4yt.png)

![GjtdA0.png](https://s1.ax1x.com/2020/04/13/GjtdA0.png)

![GjanB9.png](https://s1.ax1x.com/2020/04/13/GjanB9.png)

#### 4.总结

![GjaTvF.png](https://s1.ax1x.com/2020/04/13/GjaTvF.png)

## 3.进程互斥

#### 3.1进程同步、进程互斥

##### 1.什么是进程同步

回顾：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。

例如进程通信中的管道通信：

读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据>读数据”的顺序来执行的。如何解决这种异步问题，就是“ 进程同步”所讨论的内容。
**同步**亦称**直接制约关系**，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上**协调**它们的**工作次序**而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

##### 2.什么是进程互斥

（注意，互斥不是指某一时刻同时只能有一个进程使用临界资源，而是某个时间段内。意思是，假如进程1先来，正在使用临界资源，中途又被调度走了，该进程2执行了，进程2需要该临界资源，但是也只能阻塞等待，它不能去访问临界资源。因为互斥。必须得等进程1彻底用完该临界资源了（即执行V操作了），说它不用了，资源释放了，才能用）

我们把**一个时间段内只允许一个进程使用**的资源称为**临界资源**。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。
对临界资源的访问，必须**互斥**地进行。互斥，亦称**间接制约关系**。**进程互斥**指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后,另一个进程才能去访问临界资源。

**进程互斥逻辑上4个部分**

![Gv2Nex.png](https://s1.ax1x.com/2020/04/13/Gv2Nex.png)

**设计互斥访问时，遵循的原则**

![Gv2T6s.png](https://s1.ax1x.com/2020/04/13/Gv2T6s.png)

#### 3.总结

![GvRlHP.png](https://s1.ax1x.com/2020/04/13/GvRlHP.png)



#### 3.2进程互斥的软件实现方法

单标志法、双标志先检查、双标志后检查、Peternson算法

都不能同时满足4个原则。

#### 3.3进程互斥的硬件实现方法

##### 中断屏蔽法

即： 关中断;临界区;开中断;

![J3L05n.png](https://s1.ax1x.com/2020/04/21/J3L05n.png)

- 优点：简单高效
- 缺点：
  - 不适用于多处理机;（因为关中断是针对本处理机来说的，另一个处理机还可以访问）
  - 只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)

##### TestAndSet(TS/TSL指令)

由硬件实现，执行过程不允许中断，只能一气呵成

![J3OXOU.png](https://s1.ax1x.com/2020/04/21/J3OXOU.png)

#### 3.4信号量机制（P和V操作都是原语的）

0.信号量机制（PV操作）可以实现的功能：

- 进程互斥
  - 设置初值为1的互斥信号量
- 进程同步
  - 设置初值为0的同步信号量，实现“一前一后”
- 对一类系统资源的申请释放
  - 设置一个信号量，初始值即为资源的数量(本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行)
  - 即例如：多台打印机的互斥管理。假如有3台，则信号量设置为3。
  - 实现起来类似互斥，只是信号量不同。假如只有一个资源，那就跟进程互斥一样。

##### 1.信号量机制

- 用户进程可以通过使用操作系统提供的**一对原语**来对**信号量**进行操作，从而很方便的实现了进程互
  斥、进程同步。
- **信号量**其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来**表示系统中某种资源的数量**，比如：系统中只有一台打印机，就可以设置一个初值为1 的信号量。
- 原语是一种特殊的程序段，其**执行只能一气呵成，不可被中断**。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。
- **一对原语**：wait(S) 原语和signal(S) 原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S 其实就是函数调用时传入的一个参数。
- wait、signal 原语常**简称为P、V操作**（来自荷兰语proberen尝试 和 verhogen增加）。因此，做题的时候常把wait(S)、signal(S) 两个操作分别写为P(S)、V(S)
- P(S)：申请资源、消耗资源、上锁     三种含义
- V(S)：释放资源、解锁       两种含义

##### 1.1信号量机制--整型信号量

整型信号量

- 用一个**整数型的变量**作为信号量，用来表示系统中某种资源的数量。

  - 与整型信号量与普通整数型变量的区别：对于整型信号量的操作只有 初始化、P操作、V操作

- ​	

  ```c++
  int S=1;//初始化整型信号量s，表示当前系统中可用的打印机资源数
  
  void wait(int S){//wait原语，相当于“进入区”
      while(S<=0);//如果资源数不够，就一直循环等待
      S=S-1;//如果资源数够，则占用一个资源
  }
  
  void signal(int S){//signal原语，相当于“退出区”
      S=S+1;//使用完资源后，在退出区释放资源
  }
  ```

- ```c++
  进程:
  ...
  wait(S);//进入区，申请资源
  使用打印机资源;//临界区，访问资源
  signal(S);//退出区，释放资源
  ...
  ```

- 会发生忙等，即占着CPU等待，不满足让权等待

##### 1.2信号量机制--记录型信号量

整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量

```c++
//记录型信号量的定义
typedef struct{
    int value;//剩余资源数
    struct process *L;//等待队列
}semaphore;
```

```c++
//某进程需要使用资源时，通过wait原语申请  P申请资源,消耗资源
void P(semaphore S){
    S.value--;
    //--后小于0，意思就是刚才要么是没资源，要么是欠资源
    if(S.value<0){//如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并挂到
        block(S.L);//信号量S的等待队列（即阻塞队列）中
    }
}

//进程使用完资源后，通过signal原语释放   V增加资源
void V(semaphore S){
    s.value++;
    //++后<=0，说明刚才肯定是个负数，有进程在等待。
    if(S.value<=0){//释放资源后，还是负数。说明还有别的进程在等待这种资源
        wakeup(S.L);//则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
    }
}  
```

- **S.value 的初值**表示系统中某种**资源的数目**。
- 对信号量S 的一次**P 操作**意味着进程**请求一个单位的该类资源**，因此需要执行S.value--，表示资源数减1，当S.value < 0 时表示该类资源已分配完毕，因此进程应调用block 原语进行自我阻塞（当前运行的进程从运行态->阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L 中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。
- 对信号量S 的一次**V 操作**意味着进程**释放一个单位的该类资源**，因此需要执行S.value++，表示资源数加1，若加1后仍是S.value <= 0，表示依然有进程在等待该类资源，因此应调用wakeup 原语**唤醒等待队列中的第一个进程**（被唤醒进程从阻塞->就绪态）。

##### 2.总结

![JGcwyq.png](https://s1.ax1x.com/2020/04/21/JGcwyq.png)

#### 3.5用信号量实现进程互斥、同步、前驱关系

注意终点

- 一个信号量对应一种资源
- 信号量的值= 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源。-1就是1个进程在等待这种资源，-3就是有3个进程在等待这种资源。每个信号量的值有一个配套的队列（队列和value在同一个struct里边），等待这种资源的进程就在相应队列里等待。）
- P( S ) —— 申请一个资源S，如果资源不够就阻塞等待
- V( S ) —— 释放一个资源S，如果有进程在等待该资源，则唤醒一个进程
- PV都是原语，肯定不会被打断

##### 1.利用信号量机制实现进程互斥

我们把**一个时间段内只允许一个进程使用**的资源称为**临界资源**。许多物理设备(比如一台摄像头、一台打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。临界资源只能互斥地访问，即只能分配给一个进程，当前访问临界资源的这个进程访问结束，释放该资源之后,另一个进程才能去访问临界资源。但是呢，进程之间会有调度，很可能这个进程还没使用完，就被调度走了，一会儿才能让它继续执行。所以实现进程互斥很有必有。

临界资源可以当做独一份的资源，所以mutex=1。它不像之前的打印机，可以有两台。临界资源一定是独一份的。

1. 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）
2. 设置互斥信号量mutex，初值为1
3. 在进入区P(mutex)——申请资源
4. 在退出区V(mutex)——释放资源

```c++
//信号量机制实现互斥
semaphore mutex=1;//初始化信号量。临界资源独一份
P1(){
    ...
    P(mutex);//使用临界资源之前加锁。如果申请通过了，即有资源，可以分配，那么往下执行。否则会在这里主动阻塞
    临界区代码段...
    V(mutex);//使用临界资源之后解锁。释放资源，同时看看有没有等待这个资源的阻塞进程，有的话，就调出来一个，即让那个阻塞进程就绪（只能调出来一个，不能都调出来）
    ...
}

P2(){
    ...
    P(mutex);//使用临界资源之前加锁
    临界区代码段...
    V(mutex);//使用临界资源之后解锁
    ...
}

```

##### 2.利用信号量机制实现进程同步

比如：P1、P2两个进程并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。

若P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之

后才会执行。

这就是进程同步：让本来是异步并发的进程互相配合，有序推进。

```c++
P1(){
    代码1;
    代码2;
    代码3;
}
```

```c++
P2(){
    代码4;
    代码5;
    代码6;
}
```

解决方案：

用信号量实现进程同步：
1. 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）
2. 设置**同步信号量S, 初始为0**
3. 在**“前操作”之后执行V(S)**
4. 在**“后操作”之前执行P(S)**

```c++
//信号量机制实现进程同步：本题的同步是指，代码4的执行，一定要在代码2之后，因为需要代码2的计算结果
semaphore S=0;
P1(){            P2(){  
    代码1;            P(S);
    代码2;前操作        代码4;后操作
    V(S);			  代码5;
    代码3;			代码6;
}                    }
//可以理解为，信号量代表某种资源，刚开始时是没有这种资源的。即初始S=0;而代码4的执行一定要有这个资源，而这种资源又只能由P1产生。
//所以代码4的执行一定在代码2之后
//可能是 1 2 3 4 5 6的顺序
//也可能 1 2 V(S)执行完以后，调度出去了，有可能是 1 2 4 5 6 3等等
//反正一定是保证了代码4在代码2之后，其它的顺序，由于进程异步性，还是没有保障的。
```

分析：两种情况，都会是代码4在代码2之后执行，实现了进程同步。

- 若进程1先执行，先执行到V(S) 操作，则S++ 后S=1。之后当执行到P(S) 操作时，由于S=1，表示有可用资源，会执行S--，S 的值变回0，P2 进程不会执行block 原语，而是继续往下执行代码4。
- 若进程2先执行，先执行到P(S) 操作，由于S=0，S-- 后S=-1，表示此时没有可用资源，因此P操作中会执行block 原语，主动请求阻塞。之后当执行完代码2，继而执行V(S) 操作， S++，使S 变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup 原语，唤醒P2 进程。这样P2 就可以继续执行代码4 了。

##### 3.实现进程的前驱关系

类似拓扑排序，有很多前后依赖关系。也就是**多级的同步问题。**

![JJLCFJ.png](https://s1.ax1x.com/2020/04/21/JJLCFJ.png)

##### 4.总结

![JJLsXV.png](https://s1.ax1x.com/2020/04/21/JJLsXV.png)

#### 3.6生产者-消费者问题

##### 1.题目描述：

- 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注: 这里的“产品”理解为某种数据)
- 生产者、消费者共享一个**初始为空、大小为n的缓冲区**。
- 只有**缓冲区没满**时，生产者才能把产品放入缓冲区，否则必须等待。
  - 分析一下即同步关系。**即缓冲区满时，生产者要等待消费者取走产品**
- 只有**缓冲区不空**时，消费者才能从中取出产品，否则必须等待。
  - 分析一下即同步关系。**即缓冲区空时（即没有产品时），消费者要等待生产者放入产品**
- 缓冲区是临界资源，各进程必须互斥地访问。

##### 2.PV操作题目的解题思路:

- 1.关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。
- 2.整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
- 3.设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。 (互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)

##### 3.注意是两个同步问题：

- 生产者消费者问题是一个互斥、同步的综合问题。
  - 同步是一前一后问题，没有回环。
- 对于初学者来说最难的是发现题目中隐含的两对同步关系。
- 有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。

​	<img src="https://s1.ax1x.com/2020/04/23/JamvHP.png" alt="JamvHP.png" style="zoom: 67%;" />

##### 4.具体实现：

```c++
semaphore mutex=1;//互斥信号量，实现对缓冲区的互斥访问
semaphore empty=n;//同步信号量，表示空闲缓冲区的数量
semaphore full=0;//同步信号量，表示产品的数量，也即非空缓冲区的数量
```

```c++
//用于实现互斥的P，一定要在实现同步的P之后
//两个V操作，顺序可以互换。P不能换
producer(){
    while(1){
        生产一个产品;
        P(empty);//消耗一个空闲缓冲区
        P(mutex);//为了让生产者、消费者进程，互斥地访问缓冲区。即上锁
        把产品放入缓冲区;//
        V(mutex);//解锁
        V(full);//增加一个产品。这一步是经典的同步，初始时full=0,consumer进程必须得等待一个v(full)后才能使用。（这就是同步）
    }
}
```

```c++
//用于实现互斥的P，一定要在实现同步的P之后
//连个V操作，顺序可以互换，P不能换
consumer(){
    while(1){
        P(full);//消耗一个产品(非空缓冲区)
        P(mutex);//上锁
        从缓冲区取出一个产品;
        V(mutex);//解锁
        V(empty);//增加一个空闲缓冲区。当empty为0时，producer进程必须得等待一个v(empty)才能使用，否则只能阻塞。（这就是同步）
        使用产品;
    }
}
```

- 生产者进程生产放置产品和消费者进程取出使用产品，是在一个缓冲区中，所以不止是两个生产者进程不能同时生产，也不能一边生产一边消费。即producer和consumer进程也得互斥，用同一个mutex
- 初始时empty=n,full=0。是因为，开始时没有产品，consumer进程必须得等待producer进程来V(full)一下，才能开始。开始时，producer进程可以无条件执行，不用等consumer进程，因为缓冲区远远没满。
- 用于实现互斥的信号量，是在同一个进程中P一下，再V一下，即P(mutex)、V(mutex)
- 用于实现同步的信号量，是在一个进程中P，另一个进程中V。例如P(full) 和V(full)就不会出现在同一个进程里

##### 5.分析

- 一个进程内，用于实现互斥的P(mutex)**不能**放在用于实现同步的P(empty)或者是P(full)之前。换句话说，**用于实现同步的P一定要在实现互斥的P之前。**
  - 也就是说在**互斥区，严禁发生阻塞，即不能有用于同步的P**。（就不能给它发生阻塞的机会）
  - 因为有可能出现死锁，循环等待对方让出。
    - 即生产者等待消费者释放空闲（empty)缓冲区（没有empty位置，即共享缓存区产品满了，它要等者消费一个以后才能生产），而消费者等待生产者释放临界区(mutex被生产者占用，它没法消费了）。
    - 或者是消费者等待生产者释放非空(full)缓冲区（没有full位置，即共享缓存区没产品了，它要等生产者生产一个以后才能生产），而生产者在等待消费者释放临界区(mutex被消费者占用，它没法生产了）。
- V操作不会导致阻塞，所以一个进程内的两个V操作可以互换位置
- 生产者生产一个产品这个操作可以放到P(mutex)之后，即紧挨着把产品放入缓冲区。消费者使用这个产品也可以放到V(mutex)之前，即紧挨着取出产品。他们本来都是放在所有的PV操作之外的，也可以放在里边。比如我们可以让消费者取出产品之后，立即就使用产品，使用完再解锁，即V操作。
  - 但是呢，这会让临界区代码量变大，每个进程占据的临界区时间变大，会严重增加其他进程访问临界区的等待时间，降低进程并发度。所以非必要代码，不要放在PV操作之间。做完必要操作之后，就立即释放资源。

#### 3.7多生产者-多消费者问题

#### 3.8吸烟者问题

#### 3.9读者-写者问题（读写锁）

有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求:

- ①允许多个读者可以同时对文件执行读操作;
- ②只允许一个写者往文件中写信息;
- ③任一写者在完成写操作之前不允许其他读者或写者工作;
- ④写者执行写操作前，应让已有的读者和写者全部退出。



#### 3.10哲学家进餐问题

##### 问题描述

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一-碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

- 关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。
- 整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。
- 信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。

```c++
//直观想法
semaphore chopstick[5]={1,1,1,1,1};
Pi(){//i号哲学家的进程
    while(1){
        P(chopstick[i]);//拿起左筷子
        P(chopstick[(i+1)%5]);//拿右筷子
        吃饭...
        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
        思考...
    }
}
//这样做的话，假若每个人都拿起左筷子就调度走。会导致每位哲学家循环等待右边的人放下筷子（阻塞）。发生“死锁”。
```

##### 避免死锁的方法

- 可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的

- 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。

- 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。

  - ```c++
    semaphore chopstick[5]={1,1,1,1,1};
    semaphore mutex = 1; //互斥地取筷子
    Pi (){ //i号哲学家的进程
        while(1){
            P(mutex);
            P(chopstick[i]); //拿左
            P(chopstick[(i+1)%5]); //拿右
            V(mutex);
            吃饭…
            V(chopstick[i]); //放左
            V(chopstick[(i+1)%5]); //放右
            思考…
        }
    }
    //这种方法并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子。更准确的说法应该是：各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。
    ```

    

#### 3.11管程

##### 1.为什么引入管程

- 管程也是用于进程的互斥和同步的——它是一种高级同步机制
- 由于信号量机制编写程序苦难、易出错。然后就设计出了管程这种机制，让程序员写程序时不需要再关注复杂的PV操作，写代码更轻松

##### 2.管程的定义和基本特征

由于进程之间存在共享资源，所以就需要互斥和同步。

管程是一种特殊的软件模块，有这些部分组成:

- 1.局部于管程的**共享数据结构**说明;（需要定义与共享资源相对应的数据结构）
- 2.对该数据结构进行操作的**一组过程**;（即对数据结构进行操作的函数）
- 3.对局部于管程的共享数据设置初始值的语句;（要有对数据结构初始化的代码）
- 4.管程有一个名字。

管程的基本特征:

- 局部于管程的数据只能被局部于管程的过程所访问;（相当于类的private数据，只能被类的函数使用）
- 一个进程只有通过调用管程内的过程才能进入管程访问共享数据;
- **每次仅允许一个进程在管程内执行某个内部过程。**

##### 3.用管程解决生产者消费者问题

```c++
//定义一个管程，跟定义一个类差不多
//这里的full,empty跟之前p v 里边的信号量含义不一样了。这里的含义是两个队列？
//wait() signal函数也仅仅是假如排队和唤醒的意思，不是PV操作了
monitor ProducerConsumer
    condition full,empty;//条件变量用来实现同步（排队）
	int count=0;//缓存区中的产品数
	//还可以定义用于描述缓冲区的数据结构，这里省去了

	void insert(Item item){//把产品item放入缓冲区
        if(count==N)
            wait(full);//阻塞，排队去
        count++;
        insert_item(item);
        if(count==1)
            signal(empty);//wakeup一下
    }
	
	Item remove(){//从缓冲区中取出一个产品
        if(count==0)
            wait(empty);//阻塞，排队区
        count--;
        if(count==N-1)
            V(full);//wakeup一下
        return remove_item();
    }
end monitor;
```

```c++
//生产者进程
producer(){
    while(1){
        item=生产一个产品;
        ProducerConsumer.insert(item);
    }
}
```

```c++
//消费者进程
consumer(){
    while(1){
        item=ProducerConsumer.remove();
        消费产品item;
    }
}
```

- 其实就是把好多个PV操作进行了封装
- 程序员生产、消费，都只用一个函数就行
- 管程里的互斥特性是靠编译器实现的
- 管程一样的实现了同步机制

##### 4.Java中类似管程的机制

Java中，如果用关键字synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用。

```java
static class monitor{
    private Item buffer[]=new Item[N];
    private int coount=0;
    
    //用synchronized关键字后，每次只能有一个线程进入insert函数，如果多个线程同时调用Insert函数，则后来者需要排队等待。等之前使用的彻底离开后，它才能用。
    public synchronized void insert(Item item){
        ....
    }
}
```

##### 5.总结

![JdKlVI.png](https://s1.ax1x.com/2020/04/23/JdKlVI.png)

## 4.死锁

### 4.1死锁的概念

#### 1.什么是死锁

在并发环境下，各进程因竞争资源而造成的一种**互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进**的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。

#### 2.进程死锁、饥饿、死循环的区别

- 死锁:各进程**互相等待对方手里的资源**，导致各进程都阻塞，无法向前推进的现象。
- 饥饿:由于**长期得不到想要的资源**，某进程无法向前推进的现象。比如:在短进程优先(SPF) 算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”
- 死循环:某进程执行过程中一 直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。

![JwRApt.png](https://s1.ax1x.com/2020/04/23/JwRApt.png)

#### 3.死锁产生的必要条件

需同时满足4个条件： 缺一个条件都不会死锁

- **互斥条件**:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。
- **不剥夺条件**:进程所获得的资源在未使用完之前，**不能由其他进程强行夺走**，只能主动释放。
- **请求和保持条件**:进程**已经保持了至少一个资源**，但又提出了新的资源**请求**，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源**保持**不放。
- **循环等待条件**:存在一种进程**资源的循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。

**注意!**

- **发生死锁时一定有循环等待，但是发生循环等待时未必死锁**(循环等待是死锁的必要不充分条件)
- 如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。

#### 4.什么时候会发生死锁（产生死锁的原因）

- 1.对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的。
- 2.进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。
- 3.信号量的使用不当也会造成死锁。如生产者~消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)

总之，对不可剥夺资源的不合理分配，可能导致死锁。

#### 5.死锁的处理策略

<img src="https://s1.ax1x.com/2020/04/24/JBxB8I.png" alt="JBxB8I.png" style="zoom:67%;" />

- 1.预防死锁。破坏死锁产生的四个必要条件中的一个或几个。
- 2.避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)
- 3.死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措
  施解除死锁。

#### 6.总结

![image.png](https://i.loli.net/2020/04/23/QhFDvxGTbHN7VOM.png)

### 4.2死锁的处理策略——预防死锁（破坏4个必要条件之一）

#### 1.破坏互斥条件

**互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁。

**破坏方法：**

如果	，则系统不会进入死锁状态。比如: SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技 术将打印机改造为共享设备...

- ![Jw7Vcd.png](https://s1.ax1x.com/2020/04/23/Jw7Vcd.png)

**该策略的缺点:**

并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。

#### 2.破坏不剥夺条件

**不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。

**破坏不剥夺条件：**

- 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。
- 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）

**该策略的缺点：**

1. 实现起来比较复杂。
2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。
3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量。
4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。

#### 3.请求和保持条件

**请求和保持条件：**进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。

**破坏方法：**

可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

该策略实现起来简单，但也有明显的**缺点：**

有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。

#### 4.循环等待条件

**循环等待条件：**存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。

**破坏方法：**

可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。
原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。

**该策略的缺点：**

1. 不方便增加新的设备，因为可能需要重新分配所有的编号；
2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；
3. 必须按规定次序申请资源，用户编程麻烦。

#### 5.总结

![Jwbh1e.png](https://s1.ax1x.com/2020/04/23/Jwbh1e.png)

### 4.3死锁的处理策略——避免死锁(银行家算法)

#### 1.什么是安全序列

- 所谓**安全序列**，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是**安全状态**。当然**，安全序列可能有多个**。
- 如果分配了资源之后，系统中找不出任何一个安全序列，系统接下来就进入了**不安全状态**。这就意味着之后**可能**所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那**系统也有可能重新回到安全状态**，不过我们在分配资源之前总是要考虑到最坏的情况。
- 如果系统处于**安全状态**，就**一定不会**发生**死锁**。如果系统进入**不安全状态**，就**可能**发生**死锁**(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)
- 因此可以**在资源分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源分配请求。这也是“**银行家算法**”的核心思想。

#### 2.什么是系统的不安全状态，与死锁有何联系

- 处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态
- 系统处于安全状态一定 不会死锁。

#### 3.如何避免系统进入不安全状态——银行家算法

**数据结构：**

- n个进程，m种资源
- 系统还有多少可用资源：Available (1,m) 向量
- 当前进程（P0到Pn的一个）提出的需求：Request  (1,m)向量
- 最大需求：Max （n,m)数组
- 已分配：Allocation (n,m)数组
- 最多还需要：Need=Max-Allocation  (n,m)数组
- <img src="https://s1.ax1x.com/2020/04/24/J0bvM4.png" alt="J0bvM4.png" style="zoom:67%;" />



**银行家算法步骤:**

- ①检查此次申请是否超过了之前声明的最大需求数
  - 比如当前P0进程提出了需求，Request0，那就要和Need(0,:)的3个元素一一对比。一旦有值超过了最大需求，就认为这个进程有问题。直接出错。
- ②检查此时系统剩余的可用资源是否还能满足这次请求
  - 也就是说P0提出的需求Request0（2,1,1）小于我当前拥有的Available（3,3,2），可能可以分配，往下走
  - 假如Request向量里边3个元素，有一个比Available对应元素大，那就满足不了需求，这个进程的当前Request就得阻塞等待
- ③试探着分配，更改各数据结构
  - 不是真的分配，只是预判
  - <img src="https://s1.ax1x.com/2020/04/24/J0qgm9.png" alt="J0qgm9.png" style="zoom:67%;" />
  - 更新了这4组数据
- ④用安全性算法检查此次分配是否会导致系统进入不安全状态
  - 假如此次分配后，可以找到一组安全序列，那么系统就处于安全状态。可以正式分配Request0
  - 假如此次分配后，找不到安全序列，那么系统就处于不安全状态，这次的假设分配需要驳回，即Request0不能答应，应该让P0阻塞

**安全性算法步骤:(银行家算法里需要执行的算法）**

- 1.检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，
- 2.并把该进程持有的资源全部回收。(该进程指**可用资源**大于**当前最多还需要**的进程，该进程加入安全序列后，把它的已分配全部收回。收回资源即更新Available=Available+已分配，并将那个进程直接删除。因为那个进程一定可以执行，它执行完就能回收删除)
- 3.不断重复上述过程，看最终是否能让所有进程都加入安全序列。

### 4.4死锁的处理策略——检测和解除（检测有锁后解锁）

如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法:

- ①死锁检测算法:用于检测系统状态，以确定系统中是否发生了死锁。
- ②死锁解除算法:当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。

#### 0.建立数据结构

<img src="https://s1.ax1x.com/2020/04/24/JBjblV.png" alt="JBjblV.png" style="zoom:67%;" />

绿色边：代表已经分配出去的资源（分配边）

蓝色边：此刻的需求（请求边）

球：某一类资源的数目

P1、P2：两个进程

R1、R2：两类资源（比如打印机和屏幕）

#### 1.死锁的检测

- 依次消除与不阻塞进程相连的边，直到无边可消。
- 注：所谓不阻塞进程是指其申请的资源数还足够的进程
- 死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁

#### 2.死锁的解除

一旦检测出死锁的发生，就应该立即解除死锁。
补充:并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程
解除死锁的主要方法有:

- 资源剥夺法。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
- 撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。
- 进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。

如何决定对谁动手：

1. 进程优先级

2. 已执行多长时间

3. 还要多久能完成
4. 进程已经使用了多少资源
5. 进程是交互式的还是批处理式的

#### 3.总结

![JBxFCn.png](https://s1.ax1x.com/2020/04/24/JBxFCn.png)

# 2.5Leetcode多线程题目

## 0.基础知识

### 1.std::thread和.join()

对于创建的线程，一般会在其销毁前调用join和detach函数；

弄清楚这两个函数的调用时机和意义，以及调用前后线程状态的变化非常重要。

- join 会使当前线程阻塞，直到目标线程执行完毕；
  - 只有处于活动状态线程才能调用join，可以通过joinable()函数检查;
  - joinable() == true表示当前线程是活动线程，才可以调用join函数；
  - 默认构造函数创建的对象是joinable() == false;
  - join只能被调用一次，之后joinable就会变为false，表示线程执行完毕；
  - 调用 ternimate()的线程必须是 joinable() == false;
  - 如果线程不调用join()函数，即使执行完毕也是一个活动线程，即joinable() == true，依然可以调用join()函数；
- detach 将thread对象及其表示的线程分离；
  - 调用detach表示thread对象和其表示的线程完全分离；
  - 分离之后的线程是不在受约束和管制，会单独执行，直到执行完毕释放资源，可以看做是一个daemon线程；
  - 分离之后thread对象不再表示任何线程；
  - 分离之后joinable() == false，即使还在执行；

```c++
#include<iostream>
#include<thread>

using namespace std;

void thread1() {
    for(int i=0;i<20;++i)
        cout << "thread1..." << endl;
}

void thread2() {
    for (int i = 0; i<20; ++i)
        cout << "thread2..." << endl;
}

int main(int argc, char* argv[]) {
    thread th1(thread1);   //实例化一个线程对象th1，该线程开始执行
    
    //th1.joinable()一开始是true，即可以让父进程等待th1
    //执行完th1.join()后，th1.joinable()就变成false了
    if(th1.joinable())
    {
        cout<<"waiting for th1"<<endl;
        th1.join();//让父进程等待th1执行完，再往下执行。即让主进程进入阻塞等待。
    }

    thread th2(thread2);
    if(th2.joinable())
    {
        cout<<"waiting for th2"<<endl;
        th2.join();
    }
    cout << "main..." << endl;
    return 0;
}
```

### 2.detach()

- 将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。一旦线程执行完毕，它所分配的资源将会被释放。
- detach是用来分离线程，这样线程可以独立地执行，不过这样由于没有thread对象指向该线程而失去了对它的控制，当对象析构时线程会继续在后台执行，但是当主程序退出时并不能保证线程能执行完。如果没有良好的控制机制或者这种后台线程比较重要，最好不用detach而应该使用join。
  - **也就是detach()出去的子进程，很有可能在main()执行完时，detach出去的子进程还没执行完，但是main（）执行完了以后就把子进程需要执行的函数段（比如thread1()函数)内存给删除了，这样会出错**

```c++
#include<iostream>
#include<thread>

using namespace std;

void thread1() {
    for(int i=0;i<20;++i)
        cout << "thread1..." << endl;
}

void thread2() {
    for (int i = 0; i<20; ++i)
        cout << "thread2..." << endl;
}

int main(int argc, char* argv[]) {
    thread th1(thread1);   //实例化一个线程对象th1，该线程开始执行
    thread th2(thread2);
    th1.detach();
    th2.detach();
    cout << "main..." << endl;
    return 0;
}
```

### 3.mutex

- **头文件是，mutex是用来保证线程同步的，防止不同的线程同时操作同一个共享数据。**
- **#include：该头文件主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock_guard, std::unique_lock, 以及其他的类型和函数。**

```c++
//mutex是不安全的，当一个线程在解锁之前异常退出了，那么其它被阻塞的线程就无法继续下去。
//mutex只能是信号量为1，若想自定义信号量应该用sem_t
mutex m;//互斥锁，即信号量为1
m.lock();//即P(m)
m.unlock();//即V(m)
```

```c++
//使用lock_guard则相对安全，它是基于作用域的，能够自解锁，当该对象创建时，它会像m.lock()一样获得互斥锁，当生命周期结束时，它会自动析构(unlock)，不会因为某个线程异常退出而影响其他线程。
//即lock_guard自动做到了m.lock()和m.unlock()，并且还更安全一点
mutex m;

{
    lock_guard<mutex> lockGuard(m);
}

```

```c++
//std::unique_lock<std::mutex> ;一般跟条件变量一起使用，当条件变量满足某些条件时，可以自动解锁，lock_guard就不行。若单纯用unique_lock，不加条件变量，那跟lock_guard功能一样
mutex m;
{
	std::unique_lock<std::mutex> lk(m);//即在这里上锁，直到作用域尾解锁。跟lock_guard功能一样
}
```



### 4.获取线程ID

线程ID是一个线程的标识符，C++标准中提供两种方式获取线程ID；

1. thread_obj.get_id();
2. std::this_thread::get_id()

有一点需要注意，就是空thread对象，也就是不表示任何线程的thread obj调用get_id返回值为0；

此外当一个线程被detach或者joinable() == false时，调用get_id的返回结果也为0。

```c++
cout << t.get_id() << ' ' << this_thread::get_id() << endl;
//t.detach();
t.join();
cout << t.get_id() << ' ' << std::this_thread::get_id() << endl;
```

### 5.semaphore

```c++
sem_t sem1;//声明一个信号量
int sem_init(&sem1,0,0);//第一个参数是要初始化的信号量;第二个参数=0即只能线程间来互斥或者同步，第二个参数≠0则可以用来进程间的互斥或者同步;第三个数字代表信号量初值
//sem_wait(&sem_z)==0是sem_wait函数返回成功了。不管申请没申请到，这步的返回值都是0。否则就是未知error了
sem_wait(&sem1);//即P(sem1)。P操作里，一旦没申请成功，有block()这一步
sem_post(&sem1);//即V(sem1)。要记住，V（）操作里包含有wakeup()这一步
```

### 6.条件变量

```c++
 std::condition_variable con1;//条件变量。相当于一种资源的阻塞队列。
 std::mutex my_mutex;//互斥量，就是最简单的进程互斥。
std::unique_lock<std::mutex> lk(my_mutex);

con1.wait(lk,[this]()->bool{return counter==2;}); // 阻塞当前线程，直到条件变量被唤醒。并且会释放lk，即解锁，好让其他线程执行。 [this]()->bool{return counter==2;}是Lambda表达式

 con1.notify_one();//若任何线程在con1上等待，则调用 notify_one 会解阻塞(唤醒)等待线程之一。
        //换句话说，con1.notify_one()是con1.wait()的唤醒

//伪唤醒，底层设计时没有保证每次执行wait都是由notify唤醒，所以需要自己加个条件（比如lambda表达式）判断一下，是不是真的可以执行了
```

### 7.原子操作

<img src="https://s1.ax1x.com/2020/04/27/JhUBdK.png" alt="JhUBdK.png" style="zoom:67%;" />

```c++
//atomic是原子操作，只对当前变量同步（读和写），不对操作（中间步骤）同步，操作同步用锁来实现
//答案是，不能保证
h2.load();
h2.store();
保证了别的线程中已发生的修改（比如已经store了个新值），我在本线程执行到load时，保证一定是能看到的，也就是load到的一定是最新值。可是别的线程都还没有store，我本线程就Load了，那肯定是旧值（未发生改动的值）啊。也就是说，一个线程store()，一个线程load()，这并不会自动限制说有store的线程先执行，有load的线程后执行。而是如果已经发生过store了，那么load的一定是最新值。如果store发生都还没发生，那load的肯定是没store之前的值。
```

### 8.总结

#### 1.两种题型

- 一种是要在一个线程里循环执行的
  - 比如交替打印零与奇偶数，只有3个线程，但是要打印0-15。
  - 这种的典型特征是，函数一进去就得写个while(1)
- 一种是一个进程只执行一次，系统会创建很多线程
  - 比如H2O生成
  - 这种一般就得考虑函数一进去就得加锁了。

#### 2.四种方法

- 信号量法（sem_t)            ：比较难
  - 注意结束时，其它wait进程的释放
- unique_lock<>lk(mutex) + 条件变量            ：还行
  - 这两句话一定紧挨着写，有些判断写在它俩之间好像不起作用
  - 注意结束时，其它wait进程的释放
- flag+yield():         一般是一进来就while得那种，用flag+yield()                   ：还行
  - 有时候是mutex+flag+yield()  ：一般一进来非while型，只执行一次型，用mutex+yield()
  - 其实跟unique_lock<>lk(mutex) + 条件变量法很像，只是少了很多代码，大体上框架一致。不用加锁了，不用唤醒了。
  - 这种可以放心大胆不要锁，是因为其他进程都在yield谦让，它们不会执行去修改数据。每一种cur下，应该输出的进程没执行完，是不会有其他进程执行的。
  - 有两种思路，一种是全部控制权在一个线程里，它来分发flag。就是说不管执行哪个线程，那个控制线程都得执行一遍。另一种思路就是各自判断，各自为战，4个线程等权。
  - 这种方式一般可以无锁。（一直while)
- 原子操作（不推荐）
  - 用`atomic<int> i`的，一般都不对。用`atomic<bool> flag`的，好像跟flag+yield()没什么区别
  - 结论是...原子操作好像在这里没用

## 1.按序打印

### 方法1：使用std::mutex 互斥锁，默认信号量为1

```c++
//mutex这个类是互斥锁，即默认信号量为1
//lock()操作相当于P()
//unlock()操作相当于V()
class Foo {
public:
    Foo() {
        sem1.lock();//先把两个信号量降为1，再进程同步
        sem2.lock();//用于进程同步的信号量一般是0
    }

    void first(function<void()> printFirst) {
        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        sem1.unlock();//V(sem1)
    }

    void second(function<void()> printSecond) {
        sem1.lock();//P(sem1)
        // printSecond() outputs "second". Do not change or remove this line.
        printSecond();       
        sem2.unlock();//V(sem2)
    }

    void third(function<void()> printThird) {
        sem2.lock();//P(sem2)
 		// printThird() outputs "third". Do not change or remove this line.
        printThird();
    }
private:
    std::mutex sem1,sem2;
};
//符合之前讲的进程同步，
```

### 方法2：自定义信号量(使用semaphore.h)

```c++
#include <semaphore.h>
class Foo {
private:
    sem_t sem1,sem2;
public:
    Foo() {
        sem_init(&sem1,0,0);//第二个参数=0，即单进程的线程共享。即只能同步线程
        sem_init(&sem2,0,0);//若第二个参数≠0，则多进程之间共享。即可以用来同步进程
        //第三个参数是信号量初值，设为0
    }

    void first(function<void()> printFirst) {

        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        sem_post(&sem1);//V(sem1)
    }

    void second(function<void()> printSecond) {
        sem_wait(&sem1);//P(sem1)
        // printSecond() outputs "second". Do not change or remove this line.
        printSecond();
        sem_post(&sem2);//V(sem2)
    }

    void third(function<void()> printThird) {
        sem_wait(&sem2);//P(sem2)
        // printThird() outputs "third". Do not change or remove this line.
        printThird();
    }
};
```

### 方式3：互斥锁+条件变量

```c++
//条件变量condition_variable只能和unique_lock一起使用
//condition.wait()函数都在会阻塞时，自动释放锁权限，即调用unique_lock的成员函数unlock()，以便其他线程能有机会获得锁
//三个线程各自上锁，
class Foo {
public:
    Foo() {
        
    }

    void first(function<void()> printFirst) {
        std::unique_lock<std::mutex> lk(my_mutex);//即在这里上锁，直到作用域尾解锁
        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        counter++;
        con1.notify_one();//若任何线程在con1上等待，则调用 notify_one 会解阻塞(唤醒)等待线程之一。
        //换句话说，con1.notify_one()是con1.wait()的唤醒
    }

    void second(function<void()> printSecond) {
        std::unique_lock<std::mutex> lk(my_mutex);
        con1.wait(lk,[this]()->bool{return counter==2;}); // 阻塞当前线程，直到条件变量被唤醒。并且会释放lk，即解锁。 [this]()->bool{return counter==2;}是Lambda表达式
        // printSecond() outputs "second". Do not change or remove this line.
        printSecond();
        counter++;
        con2.notify_one();
    }

    void third(function<void()> printThird) {
         std::unique_lock<std::mutex> lk(my_mutex);
         con2.wait(lk,[this]()->bool{return counter==3;});//counter没到3，说明之前两个没执行，那么进程到con2上阻塞等待,并解了上一步的lk.
        // printThird() outputs "third". Do not change or remove this line.
        printThird();
    }
private:
    int counter=1;
    std::condition_variable con1;//条件变量。相当于一种资源的阻塞队列。
    std::condition_variable con2;
    std::mutex my_mutex;//互斥量，就是最简单的进程互斥。
};

```

## 2.交替打印字符串(与第6题差不多)

### 1. 采用信号量

```c++
#include<semaphore.h>
class FizzBuzz {
private:
    int n;//1-n输出
    int cur;//
    sem_t sem_fizz;//3个同步信号量
    sem_t sem_buzz;
    sem_t sem_fizz_buzz;
    sem_t sem_num;//1互斥信号量？

public:
    FizzBuzz(int n) {
        this->n = n;
        cur = 1;
        sem_init(&sem_fizz, 0, 0);//信号量初始化
        sem_init(&sem_buzz, 0, 0);
        sem_init(&sem_fizz_buzz, 0, 0);
        sem_init(&sem_num, 0, 1);
    }

    // printFizz() outputs "fizz".

    /*入参std::function<void()>是一个模板类对象，
    它可以用一个函数签名为void()的可调用对象来进行初始化；
    上述实现里面是一个传值调用。我们来看一下它的调用过程，*/
    void fizz(function<void()> printFizz) {
        while(cur <= n){
            sem_wait(&sem_fizz);
            if(cur > n) break;
            printFizz();
            cur++;
            sem_post(&sem_num);
        }
    }

    // printBuzz() outputs "buzz".
    void buzz(function<void()> printBuzz) {
        while(cur <= n){
            sem_wait(&sem_buzz);
            if(cur > n) break;
            printBuzz();
            cur++;
            sem_post(&sem_num);
        }
    }

    // printFizzBuzz() outputs "fizzbuzz".
    void fizzbuzz(function<void()> printFizzBuzz) {
        while(cur <= n){
            sem_wait(&sem_fizz_buzz);
            if(cur > n) break;
            printFizzBuzz();
            cur++;
            sem_post(&sem_num);
        }
    }

    // printNumber(x) outputs "x", where x is an integer.
    void number(function<void(int)> printNumber) {
        while(cur <= n){
            sem_wait(&sem_num);
            if(cur > n) break;
            if(cur % 3 == 0 && cur % 5 == 0){
                sem_post(&sem_fizz_buzz);
            }else if(cur % 3 == 0){
                sem_post(&sem_fizz);
            }else if(cur % 5 == 0){
                sem_post(&sem_buzz);
            }else{
                printNumber(cur);
                cur++;
                sem_post(&sem_num);
            }
        }

        // 以下三个post通过更新sem_fizz等信号量，调动其他线程运行，进而结束所有线程
        sem_post(&sem_fizz);
        sem_post(&sem_buzz);
        sem_post(&sem_fizz_buzz);
    }
};
```

### 2. atomic（该方法错误）

```c++
//该方法错误！因为i.load()是原子的，不代表往下执行也是原子的。比如number函数中，此时i=15，进入了while,然后线程切了出去，再回来时，i已经是16了。
class FizzBuzz {
private:
    int n;
    int cur;

public:
    FizzBuzz(int n) {
        this->n = n;
        i=1;
    }

    // printFizz() outputs "fizz".
    void fizz(function<void()> printFizz) {
        while(i.load(memory_order_acquire)<=n){//i.load(memory_order_acquire)保证了这个线程后边的所有读写操作不能被排在它之前
            if(i%3==0 && i%5!=0){
                printFizz();
                i++;
            }
            else{
                this_thread::yield();
            }
        }
    }

    // printBuzz() outputs "buzz".
    void buzz(function<void()> printBuzz) {
        while(i.load()<=n){//i.load()默认的是memory_order_seq_cst
            if(i%5==0 && i%3!=0){
                printBuzz();
                i++;
            }
            else{
                this_thread::yield();
            }
        }
    }

    // printFizzBuzz() outputs "fizzbuzz".
	void fizzbuzz(function<void()> printFizzBuzz) {
        while(i.load()<=n){
            if(i%5==0 && i%3==0){
                printFizzBuzz();
                i++;
            }
            else{
                this_thread::yield();
            }
        }
    }

    // printNumber(x) outputs "x", where x is an integer.
    void number(function<void(int)> printNumber) {
        while(i.load()<=n){

            if(i%5!=0 && i%3!=0){
                printNumber(i);
                i++;
            }
            else{
                this_thread::yield();
            }
        }
    }
};
```

### 3.flag+yield（可以有控制线程，也可以等权）

#### 1.number是控制线程法

```c++
//number线程是控制flag的线程，其它线程结束后都得执行一次number线程，等待Number线程配置flag。
class FizzBuzz {
private:
	int n;
	int cur;
	int flag;//flag=0 number。flag=1 fizz。 flag=2 buzz,flag=3 fizzbuzz
public:
	FizzBuzz(int n) {
		this->n = n;
		cur = 1;
		flag = 0;
	}

	// printFizz() outputs "fizz".
	void fizz(function<void()> printFizz) {
		
		while (1) {
			while (flag!=1 && cur<=n) this_thread::yield();
			if (cur > n) break;//用于结束线程
			printFizz();
			cur++;
			flag = 0;//交还控制权
		}
	}

	// printBuzz() outputs "buzz".
	void buzz(function<void()> printBuzz) {
		while (1) {
			while (flag!=2 && cur <= n) this_thread::yield();
			if (cur > n) break;//用于结束线程
			printBuzz();
			cur++;
			flag = 0;
		}
	}

	// printFizzBuzz() outputs "fizzbuzz".
	void fizzbuzz(function<void()> printFizzBuzz) {
		while (1)
		{
			while (flag!=3 && cur <= n) this_thread::yield();
			if (cur > n) break;//用于结束线程
			printFizzBuzz();
			cur++;
			flag = 0;
		}
	}

	// printNumber(x) outputs "x", where x is an integer.
	void number(function<void(int)> printNumber) {
		while (1)
		{
			while (flag!=0 && cur <= n) this_thread::yield();
			if (cur % 3 == 0 && cur % 5 != 0) flag = 1;
			else if (cur % 3 != 0 && cur % 5 == 0) flag = 2;
			else if (cur % 3 == 0 && cur % 5 == 0) flag = 3;
			else flag = 0;
			if (cur > n) break;//用于结束线程
			if (flag != 0) continue;//flag不是0，说明不该本线程执行，continue出去
			printNumber(cur);
			cur++;
		}
	}
};
```

#### 2.  4个线程等权

```c++
//4个线程等权，各自判断。就是不要number来控制flag了
class FizzBuzz {
private:
	int n;
	int cur;
public:
	FizzBuzz(int n) {
		this->n = n;
		cur = 1;
	}

	// printFizz() outputs "fizz".
	void fizz(function<void()> printFizz) {

		while (1) {
			while (!(cur % 3 == 0 && cur % 5 != 0) && cur <= n) this_thread::yield();
			if (cur > n) break;//用于结束线程
			printFizz();
			cur++;
		}
	}

	// printBuzz() outputs "buzz".
	void buzz(function<void()> printBuzz) {
		while (1) {
			while (!(cur % 5 == 0 && cur % 3 != 0) && cur <= n) this_thread::yield();
			if (cur > n) break;
			printBuzz();
			cur++;
		}
	}

	// printFizzBuzz() outputs "fizzbuzz".
	void fizzbuzz(function<void()> printFizzBuzz) {
		while (1)
		{
			while (!(cur % 5 == 0 && cur % 3 == 0) && cur <= n) this_thread::yield();
			if (cur > n) break;
			printFizzBuzz();
			cur++;
		}
	}

	// printNumber(x) outputs "x", where x is an integer.
	void number(function<void(int)> printNumber) {
		while (1)
		{
			while (!(cur % 5 != 0 && cur % 3 != 0) && cur <= n) this_thread::yield();
			if (cur > n) break;
			printNumber(cur);
			cur++;
		}
	}
};
```

### 附测试例程

```c++
int main(int argc, char** argv) {
	FizzBuzz yyd(15);
	std::function<void(int)> printNumber = [](int n) {cout << n << " "; };
	std::function<void()> printFizz = []() {cout << " fizz "; };
	std::function<void()> printBuzz = []() {cout << " Buzz "; };
	std::function<void()> printFizzBuzz = []() {cout << " fizzBuzz "; };
	std::thread th[4];

	th[0] = std::thread(&FizzBuzz::fizz, &yyd, printFizz);
	th[1] = std::thread(&FizzBuzz::buzz, &yyd, printBuzz);
	th[2] = std::thread(&FizzBuzz::fizzbuzz, &yyd, printFizzBuzz);
	th[3] = std::thread(&FizzBuzz::number, &yyd, printNumber);


	for (auto& ts : th) {
		if (ts.joinable()) ts.join();
	}

	return 0;
}
```

## 3.哲学家问题

### 1.必须同时抓起俩筷子(mutex)

```c++
//同时抓起俩筷子
class DiningPhilosophers {
private:
    std::mutex lks[5];//每只筷子一个互斥锁
    std::mutex guid;//保证拿左右筷子一气呵成
public:
    DiningPhilosophers() {
        
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
        int l=philosopher;//左筷子编号
        int r=(philosopher+1)%5;//右筷子编号
        guid.lock();//拿筷子过程要锁住
		lks[l].lock();//锁左筷子，即占据资源
        lks[r].lock();//锁右筷子
        pickLeftFork();//拿左筷子
        pickRightFork();//拿右筷子
        guid.unlock();//解锁拿筷子过程，其他线程（哲学家）可以拿筷子了
        eat();//吃
        putRightFork();//放筷子
        putLeftFork();
        lks[l].unlock();//放完筷子，将筷子资源释放
        lks[r].unlock();
    }
};
```

### 2.限制5位哲学家只能4位同时就餐(mutex+sem_t)

```c++
//限制就餐人数
#include<semaphore.h>
class DiningPhilosophers {
    private:
        sem_t count;//用于锁住入口，限制吃饭人数
        std::mutex locks[5];//用于锁住5只筷子
public:
    DiningPhilosophers() {
        sem_init(&count,0,4);//初始化信号量，即最多进入4个人
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
        int l=philosopher;//左筷子编号
        int r=(philosopher+1)%5;//右筷子编号
		sem_wait(&count);//锁住入口，饭桌上只让有4个人
        locks[l].lock();//锁住左筷子，占据左筷子资源
        locks[r].lock();//锁住右筷子
        pickLeftFork();
        pickRightFork();
        eat();        
        putLeftFork();
        putRightFork();
        locks[l].unlock();//释放左筷子资源
        locks[r].unlock();//释放右筷子资源
        sem_post(&count);//空出一个就餐位置来
    }
};
```

### 3.奇偶哲学家拿筷子顺序分开(mutex)

```c++
//奇偶分开，拿筷子顺序不一样。
//这样相邻两个哲学家要进餐时就会发生争抢筷子,一定不会都拿起左筷子
class DiningPhilosophers {
    private:
        mutex locks[5];//用于锁住5只筷子
public:
    DiningPhilosophers() {
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
        int l=philosopher;//左筷子编号
        int r=(philosopher+1)%5;//右筷子编号
        if(l%2==0)
        {//先左后右
            locks[l].lock();//锁住左筷子，占据左筷子资源
            locks[r].lock();//锁住右筷子
            pickLeftFork();
            pickRightFork();
            eat();        
            putLeftFork();
            putRightFork();
            locks[l].unlock();//释放左筷子资源
            locks[r].unlock();//释放右筷子资源
        }                
        else{//先右后左
            locks[r].lock();//锁住右筷子
            locks[l].lock();//锁住左筷子，占据左筷子资源
            pickLeftFork();
            pickRightFork();
            eat();        
            putLeftFork();
            putRightFork();
            locks[l].unlock();//释放左筷子资源
            locks[r].unlock();//释放右筷子资源           
        }

    }
};
```

### 4.筷子编码，只能先拿较小的(mutex)

```c++
//筷子编码，必须先拿左右里边较小的
//这样在循环拿起左筷子的时候，到最后一个哲学家时，它是右筷子编号小，左筷子编号大，而右筷子被0号哲学家拿走了，他只能等待，而不能拿起他的左筷子
#include<semaphore.h>
class DiningPhilosophers {
    private:
        mutex locks[5];//用于锁住5只筷子
public:
    DiningPhilosophers() {
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
        int l=philosopher;//左筷子编号
        int r=(philosopher+1)%5;//右筷子编号
        if(l<r)
        {//左边小，先拿左边
            locks[l].lock();//锁住左筷子，占据左筷子资源
            locks[r].lock();//锁住右筷子
            pickLeftFork();
            pickRightFork();
            eat();        
            putLeftFork();
            putRightFork();
            locks[l].unlock();//释放左筷子资源
            locks[r].unlock();//释放右筷子资源
        }                
        else{//右边小，先拿右边
            locks[r].lock();//锁住右筷子
            locks[l].lock();//锁住左筷子，占据左筷子资源
            pickLeftFork();
            pickRightFork();
            eat();        
            putLeftFork();
            putRightFork();
            locks[l].unlock();//释放左筷子资源
            locks[r].unlock();//释放右筷子资源           
        }

    }
};
```

## 4.交替打印FooBar

### 1.用两个mutex

```c++
//类似于生产者消费者的同步思想
class FooBar {
private:
    int n;
    mutex lock1,lock2;
public:
    FooBar(int n) {
        this->n = n;
        lock2.lock();
    }

    void foo(function<void()> printFoo) {
        
        for (int i = 0; i < n; i++) {
            lock1.lock();
        	// printFoo() outputs "foo". Do not change or remove this line.
        	printFoo();
            lock2.unlock();
        }
    }

    void bar(function<void()> printBar) {
        
        for (int i = 0; i < n; i++) {
            lock2.lock();
        	// printBar() outputs "bar". Do not change or remove this line.
        	printBar();
            lock1.unlock();
        }
    }
};
```

### 2.用flag+yield（没有控制线程，都等权）

```c++
class FooBar {
private:
	int n;
	int flag;//flag=true执行bar,flag=false执行foo
public:
	FooBar(int n) {
		this->n = n;
		flag = 0;
	}

	void foo(function<void()> printFoo) {

		for (int i = 0; i < n; i++) {
			while (flag!=0) this_thread::yield();//flag=false,执行该线程。flag=true,yield出去
			// printFoo() outputs "foo". Do not change or remove this line.
			printFoo();
			flag = 1;
		}
	}

	void bar(function<void()> printBar) {

		for (int i = 0; i < n; i++) {
			while (flag!=1) this_thread::yield();//flag=true,执行该线程
			// printBar() outputs "bar". Do not change or remove this line.
			printBar();
			flag = 0;
		}
	}
};
```

### 3.用mutex+条件变量

```c++
class FooBar {
private:
    int n;
    int count;
    std::condition_variable con1;
    std::condition_variable con2;
    std::mutex mymutex;
public:
    FooBar(int n) {
        this->n = n;
        count=1;
    }

    void foo(function<void()> printFoo) {
        
        for (int i = 0; i < n; i++) {
            std::unique_lock<std::mutex> lk(mymutex);
            con1.wait(lk,[this](){return count==1;});
        	// printFoo() outputs "foo". Do not change or remove this line.
        	printFoo();
            count++;
            con2.notify_one();
        }
    }

    void bar(function<void()> printBar) {
        
        for (int i = 0; i < n; i++) {
            std::unique_lock<std::mutex> lk(mymutex);
            con2.wait(lk,[this](){return count==2;});
        	// printBar() outputs "bar". Do not change or remove this line.
        	printBar();
            count--;
            con1.notify_one();
        }
    }
};
```

### 附测试例程

```c++
int main(int argc, char** argv) {
	FooBar yyd(10);
	std::function<void()> printFoo = []() {cout <<  " Foo "; };
	std::function<void()> printBar = []() {cout << " Bar "; };
	std::thread th[2];

	th[0] = std::thread(&FooBar::foo, &yyd, printFoo);
	th[1] = std::thread(&FooBar::bar, &yyd, printBar);


	for (auto& ts : th) {
		if (ts.joinable()) ts.join();
	}

	return 0;
}
```



## 5.H2O生成

### 1.mutex lock+条件变量

```c++
class H2O {
private:
	int count_H;
	mutex mymutex;
	std::condition_variable con1;
	std::condition_variable con2;
public:
	H2O() {
		count_H = 0;
	}

	void hydrogen(function<void()> releaseHydrogen) {
		unique_lock<mutex> lk(mymutex);
		con1.wait(lk, [this]() {return count_H < 2; });
		// releaseHydrogen() outputs "H". Do not change or remove this line.
		releaseHydrogen();
		count_H++;
		if (count_H == 2) {
			con2.notify_one();//唤醒一个O
		}
	}

	void oxygen(function<void()> releaseOxygen) {
		unique_lock<mutex>lk(mymutex);
		con2.wait(lk, [this]() {return count_H== 2; });
		// releaseOxygen() outputs "O". Do not change or remove this line.
		releaseOxygen();	
		con1.notify_one();//唤醒两个H
		con1.notify_one();
		count_H = 0;
	}

};
```

### 2.信号量

```c++
//limit_H是用于hydrogen进程互斥，最多两个进行
//limit_O是用于oxygen进程互斥，最多1个进行
//O、H是用于进程同步的，其实也是表资源量的（它们的一半就表示真实的资源量）
//hydrogen进程一次产生1个H，消耗半个O;oxygen进程一次产生1个O，消耗两个H
//但是没有半个信号量，同时乘2。即hydrogen进程一次产生2个H，消耗1个O;oxygen进程一次产生2个O，消耗4个H
#include<semaphore.h>
class H2O {
private:
    sem_t limit_O;
    sem_t limit_H;
    sem_t O;
    sem_t H;
public:
    H2O() {
        sem_init(&limit_O,0,1);
        sem_init(&limit_H,0,2);
        sem_init(&O,0,0);
        sem_init(&H,0,0);
    }

    void hydrogen(function<void()> releaseHydrogen) {
        sem_wait(&limit_H);
        sem_post(&H);
        sem_post(&H);
        sem_wait(&O);
        // releaseHydrogen() outputs "H". Do not change or remove this line.
        releaseHydrogen();
        sem_post(&limit_H);
    }

    void oxygen(function<void()> releaseOxygen) {
        sem_wait(&limit_O);
        sem_post(&O);
        sem_post(&O);
        sem_wait(&H);
        sem_wait(&H);
        sem_wait(&H);
        sem_wait(&H);
        // releaseOxygen() outputs "O". Do not change or remove this line.
        releaseOxygen();
        sem_post(&limit_O);
    }
};
```

### 3.mutex+flag+yield()

```c++
class H2O {
private:
	int h2;//flag
	mutex omutex;
	mutex hmutex;
public:
	H2O() {
		h2 = 0;
	}

	void hydrogen(function<void()> releaseHydrogen) {
		hmutex.lock();
		while (h2>1) this_thread::yield();//while里一定要写不满足时的条件
		// releaseHydrogen() outputs "H". Do not change or remove this line.
		releaseHydrogen();
		h2++;
		hmutex.unlock();
	}

	void oxygen(function<void()> releaseOxygen) {
		omutex.lock();
		while (h2 != 2) this_thread::yield();

		// releaseOxygen() outputs "O". Do not change or remove this line.
		releaseOxygen();
		h2=0;
		omutex.unlock();
	}
};
```

### 附测试例程

```c++
int main(int argc, char** argv) {
	H2O yyd;
  //setbuf(stdout, NULL);
  std::function<void()> releaseHydrogen=[](){cout<<" H ";};
  std::function<void()> releaseOxygen=[](){cout<<" O ";};
  const int temp=4;
	std::thread th[temp*3];
  for(int i=0;i<temp;i++){
    th[i]=std::thread(&H2O::oxygen,&yyd,releaseOxygen);
  }
for(int i=temp;i<temp*3;i++)
{
  th[i]=std::thread(&H2O::hydrogen,&yyd,releaseHydrogen);
}

	for (auto& ts : th) {
		if (ts.joinable()) ts.join();
	}

	return 0;
}
```



## 6.打印零与奇偶数

### 1.sem

```c++
//要注意结束时释放线程
#include<semaphore.h>
class ZeroEvenOdd {
private:
    int n;
    int cur;
    sem_t sem_e;
    sem_t sem_o;
    sem_t sem_z;
public:
    ZeroEvenOdd(int n) {
        this->n = n;
        cur=0;
        sem_init(&sem_e,0,0);
        sem_init(&sem_o,0,0);
        sem_init(&sem_z,0,1);
    }

    // printNumber(x) outputs "x", where x is an integer.
    void zero(function<void(int)> printNumber) {
        while(1)//
        {
            sem_wait(&sem_z);
            cur++;
            if(cur>n)
                break;
            printNumber(0);
            if(cur%2==0)
                sem_post(&sem_e);
            else
                sem_post(&sem_o);
        }
        sem_post(&sem_e);//用于让even和odd进程结束
        sem_post(&sem_o);
    }

    void even(function<void(int)> printNumber) {
        while(1)
        {
            sem_wait(&sem_e);
            if(cur>n) return;
            printNumber(cur);
            sem_post(&sem_z);
        }
    }

    void odd(function<void(int)> printNumber) {
        while(1)
        {
            sem_wait(&sem_o); //这里就用到了cur的非同步特性，wait的时候cur可能是0。解开的时候cur变成1了。
            if(cur>n) return;//这步要放在wait后边，为了最后结束线程
            printNumber(cur);
            sem_post(&sem_z);
        }
    }
};
```

### 2. mutex lock+条件变量

```c++
//要注意结束时释放线程
class ZeroEvenOdd {
private:
	int n;
	int cur;
	int flag;//0标志运行zero线程。2标志运行even线程。1标志运行odd线程
	mutex mymutex;
	condition_variable con_z;
	condition_variable con_e;
	condition_variable con_o;
public:
	ZeroEvenOdd(int n) {
		this->n = n;
		cur = 0;
		flag = 0;
	}

	// printNumber(x) outputs "x", where x is an integer.
	void zero(function<void(int)> printNumber) {
		while (1)
		{
			unique_lock<mutex> lk(mymutex);
			con_z.wait(lk, [this]() {return flag == 0; });
			cur++;
			if (cur > n) {break; }
			printNumber(0);
			if (cur % 2 == 1)
			{
				flag = 1;
				con_o.notify_one();
			}
			else
			{
				flag = 2;
				con_e.notify_one();
			}
		}

		flag = 2; con_e.notify_one();//退出的时候，还要记得把even和odd线程结束了。这里先结束even，在even里结束odd
	}

	void even(function<void(int)> printNumber) {
		while (1) {
			unique_lock<mutex> lk(mymutex);
			con_e.wait(lk, [this]() {return flag == 2; });
			if (cur > n) {  break; };
			//if(cur>n) break;
			printNumber(cur);
			flag = 0;
			con_z.notify_one();
		}
		flag = 1; con_o.notify_one();//退出的时候，把odd线程结束了
	}

	void odd(function<void(int)> printNumber) {
		while (1) {
			unique_lock<mutex> lk(mymutex);
			con_o.wait(lk, [this]() {return flag == 1; });
			if(cur>n) break;//不用再结束别的线程了,别的线程都退出了
			printNumber(cur);
			flag = 0;
			con_z.notify_one();
		}
	}
};
```

### 3.flag+yield()（一定得让zero做控制线程，因为它每次都要输出）

```c++
//要注意结束时释放线程
//这种可以放心大胆不要锁，是因为其他进程都在yield谦让，它们不会执行去修改数据。一种cur下，应该输出的进程没执行完，是不会往下走的。
class ZeroEvenOdd {
private:
	int n;
	int cur;
	int flag;

public:
	ZeroEvenOdd(int n) {
		this->n = n;
		cur = 0;
		flag = 0;
	}

	// printNumber(x) outputs "x", where x is an integer.
	void zero(function<void(int)> printNumber) {
		while (1)
		{
			while (flag != 0 && cur<=n) this_thread::yield();
			cur++;
			if (cur > n) break;
			printNumber(0);
			if (cur % 2 == 1)
			{
				flag = 1;
			}
			else
			{
				flag = 2;
			}
		}
	}

	void even(function<void(int)> printNumber) {
		while (1) {
			while (flag != 2 && cur<=n) this_thread::yield();
			if (cur > n) break;//even进程会自动结束
			printNumber(cur);
			flag = 0;//归还控制权
		}
	}

	void odd(function<void(int)> printNumber) {
		while (1) {
			while (flag != 1 && cur<=n) this_thread::yield();
			if (cur > n) break;//odd进程会自动结束
			printNumber(cur);
			flag = 0;
		}
	}
};
```

### 附测试例程

```c++
int main(int argc, char** argv) {
	ZeroEvenOdd yyd(15);
	std::function<void(int)> printNumber = [](int n) {cout << n << " "; };
	std::thread th[3];

	th[0] = std::thread(&ZeroEvenOdd::zero, &yyd, printNumber);
	th[1] = std::thread(&ZeroEvenOdd::even, &yyd, printNumber);
	th[2] = std::thread(&ZeroEvenOdd::odd, &yyd, printNumber);


	for (auto& ts : th) {
		if (ts.joinable()) ts.join();
	}

	return 0;
}
```

# 3.第三章内存

## 3.1 内存基础知识

### 1.什么是内存，有何作用

- 内存是用于存放数据的硬件。可运行程序（也就是一条条指令）执行前需要先放在内存中（从硬盘加载到内存）才能被CPU处理，CPU取指令执行。
- 为什么CPU不直接从硬盘取指执行？
  - 硬盘慢，内存快。从硬盘取指令的话，CPU会有大量的IO等待
- 常用单位
  - 2^10=1024=1K
  - 2^20=1024*1024=1M
  - 2^30=1024*1024*1024=1G
- 4GB内存，表示可以存放`4*2^30` 个Byte。如果是按字节编址的话，也就是有 `4*2^30`的''小房间''，一个小房间里1个Byte。
  - 需要4*2^30个地址，也就是32位编码，才可以表示这么多地址。也就是说地址是32位的二进制数字，即8位的16进制数字，即`0x ********`。
  - 一个Byte是8bit，可以表示0-255

### 2.进程运行的基本原理

- 编译的时候，那些代码就得翻译成各种二进制指令，肯定涉及内存操作读取、内存分配等等。所以编译生成的指令中那些内存地址会使用逻辑地址（相对地址）来表示，等到程序运行时，通过重定位来分配到物理内存地址中。

### 3.从写程序到程序运行

- ![JO3CeH.png](https://s1.ax1x.com/2020/05/01/JO3CeH.png)

### 4.三种链接方式：（一般应该没有第二种）

- ![JjSTyT.png](https://s1.ax1x.com/2020/05/01/JjSTyT.png)

### 5.三种装入方式（装入其实也就是内存重定位）

也就是逻辑地址到物理地址的转换发生的阶段和方式不同。

其实也就是把内存地址写死还是内存重定位的区别

- 绝对装入：编译时，直接对物理内存访问，内存写死
- 静态重定位装入：也就是第一次载入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。
  - 也就是说，第一次载入时把内存重定位，从此就锁死了，**不能发生内存移动**了。也就不能比如说先暂时拿到硬盘再拿回来，这样做出去再回来，它本来的内存可能被别的进程给占了，所以不能允许该进程内存移动。
  - 因此该方法不好。
- 动态重定位装入：每一次运行时重定位，也就是每次进入内存时重定位（其实刚进去还没重定位，到它执行重定位）。又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换**推迟到程序真正要执行时**才进行。因此装入内存后所有的地址依然是逻辑地址（暂时的，一会儿该它执行时就映射到物理地址了）。这种方式需要一个重定位寄存器的支持。
  - 这就支持内存换入换出了
  - 并且**支持在内存中发生移动**
  - 并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间(先告诉用户有，要是物理内存不够就等着)。

### 6.总结

![JjCpZD.png](https://s1.ax1x.com/2020/05/01/JjCpZD.png)

## 3.2 内存管理的概念

### 1.内存空间的分配与回收

操作系统需要负责内存空间的分配与回收

- 操作系统怎么记录哪些内存区域已经被分配出去了，哪些是空闲的
- 内存中有很多的空闲区域，进程该放在哪个空闲区域
- 进程运行结束之后，如何将进程占用的内存空间回收

### 2.内存空间的扩充

操作系统需要提供某种技术从逻辑上对内存空间进行扩充

- 比如一个游戏大小有60GB，按理来说这个游戏程序运行之前需要把60GB数据全部放入内存。然而，实际我的电脑内存才4GB，但为什么这个游戏可以顺利运行呢？
- 这就是虚拟技术

### 3.地址转换

- 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
- 为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而**逻辑地址到物理地址的转换**（这个过程称为地址重定位，**现代操作系统一定都是动态运行时重定位**）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。

### 4.存储保护

- 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。
- 某个进程只能访问它所占用的内存资源，不能访问到其他内存

### 5.总结

![Jj74IK.png](https://s1.ax1x.com/2020/05/02/Jj74IK.png)

## 3.3 内存空间的扩充：覆盖与交换

### 1.覆盖技术（已经淘汰）

- 覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。
- 内存中分为**一个“固定区“**和**若干个”覆盖区“**
- 需要**常驻内存的段**放在**“固定区”**中，**调入后就不再调出（除非运行结束）**
- 不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存放到硬盘上

### 2.交换技术

- 交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）
- 中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。
- 暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）
- 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态

### 3.虚拟存储技术

应该在**磁盘的什么位置保存被换出的进程？**

- 具有对换功能的操作系统中，通常把**磁盘（硬盘）空间**分为**文件区和对换区**两部分。**文件区**主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用**离散分配**方式；**对换区**空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用**连续分配**方式（学过文件管理章节后即可理解）。总之，对换区的I/O速度比文件区的更快。

**什么时候应该交换？**

- **交换**通常在**许多进程运行且内存吃紧**时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。

**应该换出哪些进程？**

- 可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…（**注意：PCB 会常驻内存，不会被换出外存**）

### 4.总结

![JvBPI0.png](https://s1.ax1x.com/2020/05/02/JvBPI0.png)

## 3.4 内存空间的分配：连续分配管理方式

连续分配：指为用户进程分配的必须是一个连续的内存空间。

动态分区分配：

动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

这种方法没有内部碎片（分配给某进程的内存区域中，如果有些部分没有用上），有外部碎片（是指内存中的某些空闲分区由于太小而难以利用）

## 3.5 内存空间的分配：动态分区分配算法

在动态分区分配方式中，有很多个空闲分区都能满足需求，选择哪个空闲分区呢？

- 首次适应算法
  - 空闲表第一个，前提是内存空间足够该进程使用
- 最佳适应算法
  - 空闲内存与进程所需最接近的
- 最坏适应算法
  - 空闲内存与进程所需差别最大的
- 临近适应算法

![JvrVb9.png](https://s1.ax1x.com/2020/05/02/JvrVb9.png)

## 3.6 基本分页存储管理的基本概念

1.逻辑地址/4K=页号

2.逻辑地址%4K=页内偏移量

3.在页表查询页号对应的实际页框起始地址

4.物理地址=4K*实际页框号+页内偏移量

页表记录的就是：虚拟页号与实际页框的对应关系

**假设物理内存4GB，一页4KB，每个页表项至少3Byte？**

答：4GB/4KB=1M，即有1M页。即10^20方页。想表示页号，至少得3Byte，即用24位二进制数字表示页号。逻辑页号隐含在侧边了，不需要存储。所以有N项，该页表就需要3N Byte。

**但是一般呢，都把一个页表项用4Byte，方便存储。**

![Jx3Kk4.png](https://s1.ax1x.com/2020/05/02/Jx3Kk4.png)

## 3.7 基本地址变换机构

## 3.8 具有快表的地址变换机构

命中的话可是按页命中（就是连续访问的内存，很可能是近几页里的），命中率还是可以的。

1.假如命中，那么我直接就知道该逻辑地址对应物理地址的始址了，加上偏移，直接就可以知道真实地址。然后访问内存。（所以是一次访存，就直接是使用内存）

2。假如没命中，就要先去PCB里读出页表位置，去内存访问（第一次访存），查页表项，然后知道了真实地址的始址，加上偏移，得到真实地址，然后访问内存（第二次访存，才是使用内存）

**依据原理是：局部性原理**

- **时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）
- **空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）

**快表概念：**

快表，又称联想寄存器（TLB， translation lookaside buffer ），是一种访问速度比内存快很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本（注意啊，只保存有限个，不能把整个页表放进来），可以加速地址变换的速度。与此对应，内存中的页表（常规页表保存在内存中）常称为慢表。

**过程：**

- ① CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。
- ② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
- ③ 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）

![JxY2Mn.png](https://s1.ax1x.com/2020/05/02/JxY2Mn.png)

## 3.9 两级页表

### 1.单级页表存在什么问题？如何解决？

- 1.页表必须连续存放在内存中，因为逻辑页号是隐藏的，只记录了对应的物理页框号，一个物理页框号虽然只用3B就用表示，一般都用4B，也就是一个页表项4B。而页表呢最大1M项，那么最大整个页表就需要4MB的连续存储空间，它需要放在内存里。
  - 总结一下就是，页表可能很大（最大4MB，即`1M项*4B`刚好是4MB），它必须要求连续存放在内存，所以将会占用很多个连续页框（1K个页框，即`1K个页框*4KB`刚好是4MB），这点很不好。
  - 结局办法是，分成二级内存，每1K项存一起放在一页内存中，这1K项肯定是连续的（因为刚好一页）。同时又保证了不需要4MB连续，只需要提供4KB、4KB的连续即可，这刚好是一页，肯定连续。
- 2.没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定页表项。
  - 要是一级目录（1个，4KB，即占一页内存）+所有二级目录（1K个，4MB，即1K页内存）都同时放在内存里，那相当于没解决问题
  - 我可以只把一级目录放在内存里，需要哪个二级目录时再调进来。（那么就不需要同时占用4MB了，只需要4KB的一级目录）

### 2.两级页表的原理、逻辑地址结构

一个页表不是最大1M项吗，我1K项，1K项的分层放，分成1K*1K。之前说1M项要连续放是吧，需要连续的4MB内存，很过分。现在每1K项放一起，1K项占据4KB，刚好1页，就是最小单位，一定是连续的。

**单级页表结构的逻辑地址结构：**（页表中存的只是物理页号，只有20位，所以3Byte就够了，但是习惯上前边补0，变成4Byte）

一个完整物理地址=实际页号+页内偏移量

![JxUxoV.png](https://s1.ax1x.com/2020/05/02/JxUxoV.png)

**两级页表结构的逻辑地址结构：**

![JxwkUx.png](https://s1.ax1x.com/2020/05/02/JxwkUx.png)

### 3.如何实现地址变换？

![JzpzWj.png](https://s1.ax1x.com/2020/05/03/JzpzWj.png)

例如逻辑地址（00 0000 0002,00 0000 0001， 1111 1111 1111） （10位，10位，12位）

故意改了改数据，跟图片上不一样

- 去PCB里边查页目录表始址比如（97)，说明页目录表（第一级页表）放在内存的第97页框处，那么去实际地址（97*4K+2）处取出值，发现值是3。意思是该二级页表存放在第3页框处

- 然后去实际地址（3*4K+1)处取出值，发现值是4。说明该逻辑地址对应的真实地址在第4个页框中。

- 即`4*4K+ 1111 1111 1111b=4*4096+4095=20479`

- 所以逻辑地址（00 0000 0002,00 0000 0001， 1111 1111 1111）的实际物理地址是20479

  - 注意几个问题，第一级页表也存在内存中，谁告诉我它在内存哪呢？PCB
  - 第二级页表也在内存中，谁告诉我它在内存哪呢？第一级页表查表可得
  - 查完第二级页表，我就知道该地址的实际地址在哪一块儿了，查完第二级页表告诉我，哦在实际内存第4个页框中。具体是哪呢？第4个页框+最后的偏移量

  

### 4.两级页表问题需要注意的几个细节

**1.每一级页表项不能超过1K，因为存的时候会超过4KB，放不到一页里**

每一级页表或者说它的页表项们，存储时必须是连续的。也就是说页表要在一页内存中存储的下。

比如一共有2M项，一算一级页表有2K项，一项4B，那么就要8KB内存，它在内存中要占用2页，这是不允许的。

因为这8KB必须连续，一旦占用了两页，就可能不连续了。

因此解决办法是，再分一级，分成`2*1K*1K`，一共2M项，没问题。第3级页表、第2级页表、第一级页表。

**2.两级页表的访存次数分析（假设没有快表机构）**

所以两级页表省了空间，却在时间上要多付出一些（访存次数增多）

- 第一次访存：访问内存中的页目录表（先从PCB中知道了页目录表放在内存哪里，然后去那里查询一级页表，来知道二级页表放在哪里)
- 第二次访存：访问内存中的二级页表（知道二级页表放在哪里之后，去那里查询二级页表，来知道该虚拟地址对应的物理地址的框号）
- 第三次访存：访问目标内存单元（知道框号，知道偏移，就找到真实物理地址了，去物理地址上做我们想要做的操作）

### 5.总结

![JzkAJS.png](https://s1.ax1x.com/2020/05/03/JzkAJS.png)

## 3.10 基本分段存储管理方式



## 3.11 段页式管理方式

## 3.12 虚拟内存的基本概念

### 1.传统存储管理方式的特征、缺点

![JxEr6J.png](https://s1.ax1x.com/2020/05/02/JxEr6J.png)

**特点、缺点：**

- **一次性**：**作业必须一次性全部装入内存后才能开始运行**。这会造成两个问题：①作业很大时，不能全部装入内存，导致**大作业无法运行**；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致**多道程序并发度下降**。
  - 所有资源必须一次性装入内存，有可能内存不够，或者占用很多时间
- **驻留性**：一旦作业被装入内存，就**会一直驻留在内存中**，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。
  - 其实没必要，比如游戏场景，在这个地图时，其他地图信息没必要在内存里

### 2.局部性原理

- **时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环。很可能对同一内存多次修改）
- **空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的。他们在内存中很可能在同一页，这样快表就能命中）
- **高速缓冲技术的思想**：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。
- 计算机中的几种存储器：硬盘、内存、高速缓存、寄存器。（从慢到快，寄存器比内存快。快表机制就是用的l联想寄存器。）

### 3.虚拟内存的定义和特征

- 基于局部性原理，在程序装入时，可以将程序中**很快会用到的部分装入内存，暂时用不到的部分留在外存**，就可以让程序开始执行。

- 在程序执行过程中，当所访问的**信息不在内存**时，由**操作系统负责将所需信息从外存调入内存**，然后继续执行程序。
  - （**这就需要请求调页功能**）
- 若内存空间不够，由**操作系统负责**将内存中**暂时用不到的信息换出到外存**。
  - （**这就需要页面置换的功能**）
- 在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**

**虚拟内存有以下三个主要特征：**

- 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。（对应了传统存储方式的一次性）
- 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。（对应了传统存储方式的驻留性）
- 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

### 4.如何实现虚拟内存技术

虚拟内存的实现需要建立在离散分配的内存管理方式基础上。

- 操作系统要提供请求调页功能
  - 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。
- 操作系统要提供页面置换的功能
  - 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

## 3.13 请求分页管理方式（虚拟内存的实现方式）

**请求分页存储管理与基本分页存储管理的主要区别：**

- 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。
  - 即操作系统要提供请求调页功能，将缺失页面从外存调入内存
- 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存
  - 即操作系统要提供页面置换的功能，将暂时用不到的页面换出外存

### 1.页表机制

- 与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。
- 当内存空间不够时，要实现**“页面置换”**，操作系统需要通过某些指标来**决定到底换出哪个页面**；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。
- ![JzKPdH.png](https://s1.ax1x.com/2020/05/03/JzKPdH.png)

### 2.缺页中断机构

页面就是页，不是指页表。

- 在请求分页系统中，每当要访问的**页面不在内存**（通过页表状态位来判断）时，便产生一个**缺页中断**，然后由操作系统的**缺页中断处理程序处理中断**。
- 此时**缺页的进程阻塞**(因为调页要发生IO操作，很慢的，CPU先去干别的)，放入阻塞队列，调页**完成后再将其唤醒**，放回就绪队列。
- 如果内存中**有空闲块**，则为进程**分配一个空闲块**，将所缺页面装入该块，并修改页表中相应的页表项。
- 如果内存中**没有空闲块**，则**由页面置换算法选择一个页面淘汰**，若该页面在内存期间**被修改过**（通过页表修改标志位来判断），则要将其**写回外存**（页表有记录对应的外存地址）。未修改过的页面不用写回外存（因为你没修改，外存的跟内存的一模一样，再写回覆盖一遍就是浪费时间）。



- 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断一条指令在执行期间，可能产生多次缺页中断。（如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，假如两个页面都没在内存，则有可能产生两次中断）

- 缺页中断属于内中断中的故障

### 3.地址变换机构

**请求分页**存储管理与**基本分页**存储管理的**主要区别**：

- 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然
  后继续执行程序。
  - 操作系统要提供请求调页功能，将缺失页面从外存调入内存
- 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存
  - 操作系统要提供页面置换的功能，将暂时用不到的页面换出外存

与基本分页相比：

新增步骤1：请求调页（查到页表项时进行判断）

新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）

新增步骤3：需要修改请求页表中新增的表项

### 4.总结

![YS91Vf.png](https://s1.ax1x.com/2020/05/03/YS91Vf.png)

## 3.14 页面置换算法（把哪个页换出内存）

https://www.bilibili.com/video/BV1d4411v7u7?p=25

- 用来决定把哪个页面换出内存。
- 页面的换入、换出需要磁盘1/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率

### 1.先进先出置换算法（FIFO）

- 先进先出置换算法(FIFO) :
  - 每次选择**淘汰**的页面是**最早进入内存的页面**
- 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。
- 缺点：完全没有考虑到局部性，会有较大的缺页率，也就是**经常缺页**

### 2.最佳置换算法（OPT）

- 最佳置换算法(OPT，Optimal) :
  - 每次选择淘汰的页面将是以后永不使用，或者**在最长时间内不再被访问的页面**，这样可以保证最低的缺页率。
- 缺点：最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此**，最佳置换算法是无法实现的**。

### 3.最近最久未使用置换算法（LRU）

- 最近最久未使用置换算法(LRU，least recently used) :
  - 每次淘汰的页面是**最近最久未使用的页面**。（我不能知道以后哪个不会被访问，那么就用最近的没使用的来推测它也是以后不再访问的）
- 缺点：真实操作系统中不可能实现，每次需要记录时间戳，还得比较谁最先出现，这成本完全不能接受。虽然性能好，但是**开销太太大**

### 4.时钟置换算法（CLOCK）

或者叫最近未用（NRU，not recently used）算法

请求分页管理中的页表扩展中有这个访问位的记录。

- 循环队列，只记录0/1。
- 在访问内存时，每访问一页，就把它那页置为1，标识最近访问过。
- 在淘汰页面时，如果指针指的那页是1，那么就置为0，指针跳到下一个。如果指针指到了0，那么就是淘汰这页了。
- 缺点：在很少有缺页的进程中，那么几乎就退化成了顺序淘汰。

### 5.改进型的时钟置换算法

再设置一个快指针，定时循环把所有页面的访问位置0，这样就可以体现出最近未用的思想了，不再怕退化成顺序淘汰。同时慢指针还按原来的策略自己慢慢的查找该淘汰谁。

### 6.总结

![Yp0HGq.png](https://s1.ax1x.com/2020/05/03/Yp0HGq.png)

## 3.15 页面分配策略（一个进程分配多少页框）

### 1.驻留集

**驻留集：指请求分页存储管理中给进程分配的物理块的集合。**（也就是给一个进程分配多少个页框）

在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。

- 若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；
- 驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。

**分配方式：**（给进程多少内存）

- **固定分配**：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变
- **可变分配**：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变

**置换方式：**（进程缺页了，允不允许把其他进程的内存清出去）

- **局部置换**：发生缺页时只能选进程自己的物理块进行置换。
- **全局置换**：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

### 2.页面分配、置换策略

- **固定分配局部置换**：（肯定不考虑）
  - 系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在**运行中发生缺页**，则只能**从该进程在内存中的页面中选出一页换出**，然后再调入需要的页面。
  - 这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）
- **可变分配全局置换**：（只要缺页就给分配新的物理块）
  - 刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。
  - 采用这种策略时，**只要某进程发生缺页**，**都将获得新的物理块**，仅当空闲物理块用完时，系统才选择一个未锁定(一些系统占用的内存会进行锁定)的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个**被选中（被换出）的进程拥有的物理块会减少，缺页率会增加**。
- **可变分配局部置换**：（根据进程发生缺页的频率来动态地增加或减少进程的物理块）
  - 刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程**自己的物理块中选出一个进行换出外存**。如果**进程在运行中频繁地缺页**，系统会为该进程**多分配几个物理块**，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

### 3.调入页面的时机

- **预调页策略**：（运行前预先调入）
  - 根据空间局部性原理，**一次调入若干个相邻的页面**可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。
- **请求调页策略**：（运行中调入）
  - 进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。

### 4.从何处调页

1.系统拥有**足够的对换区空间**（硬盘中分为对换区和文件区）：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。

2.系统**缺少足够的对换区空间**：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。

3.**UNIX 方式**：运行之前进程有关的数据全部放在文件区，故**未使用过的页面**，**都可从文件区调入**。若**被使用过的页面**需要换出，**则写回对换区，下次需要时从对换区调入**。

### 5.抖动（颠簸）现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为**抖动**，或**颠簸**。产生抖动的**主要原因**是进程频繁访问的页面数目高于可用的物理块数（**分配给进程的物理块不够**）

- 为进程分配的物理块太少，会使进程发生抖动现象。
- 为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率

### 6.工作集

驻留集：指请求分页存储管理中给进程分配的内存块的集合。
工作集：指在某段时间间隔里，进程实际访问页面的集合。

工作集用来作为判断依据来调整驻留集大小。**（也就是执行的时候，看看该进程常用的局部到底有多大，也就是工作集大小。然后作为依据来决定给它分配多少页框比较合适）**

![YSmQUA.png](https://s1.ax1x.com/2020/05/03/YSmQUA.png)

# 4.第四章文件

## 4.1 概述

文件——就是一组有意义的信息/数据集合

- 计算机中存放了各种各样的文件，一个文件有哪些属性？
  - 文件名、标识符（用户看不到，操作系统为文件打的标识，每个文件独一无二）、类型、位置、大小、创建时间、上次修改时间、文件所有者信息、保护信息
- **文件内部**的数据应该怎样组织起来？（文件的逻辑结构）
  - 无结构文件（如文本文件）——由一些二进制或字符流组成，又称“流式文件”
  - 有结构文件（如数据库表）——由一组相似的记录组成，又称“记录式文件”
    - 记录是一组相关数据项的集合。（记录就比如是execl里的一行）
    - 数据项是文件系统中最基本的数据单位（数据项就相当于是那一行里的一个单元格）
  - 有结构文件中（也就是文件内部各个记录），各个记录间应该如何组织的问题——应该顺序存放？还是用索引表来表示记录间的顺序？——这是“文件的逻辑结构”
- **文件之间**又应该又应该怎么组织起来？
  - 用户可以自己创建一层一层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来了
  - 目录其实也是一种特殊的有结构文件（由记录组成），如何实现文件目录是之后会重点探讨的问题
  - 所谓的“目录”其实就是我们熟悉的“文件夹”
- **从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？**
  - 可以**“创建文件”**，（点击新建后，图形化交互进程在背后调用了**“create 系统调用”**）
  - 可以**“读文件”**，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统提供的“读文件”功能，即**read 系统调用**，将文件数据从外存读入内存，并显示在屏幕上）
    - 双击一个“abc.txt"文件，其实是先打开了记事本这个应用程序，这个应用程序又调用了read系统调用，将文件数据从外存读到内存，并显示在屏幕上。
  - 可以**“写文件”**，将更改过的文件数据写回外存（我们在“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“写文件”功能，即**write 系统调用**，将文件数据从内存写回外存）
    - 我们编辑这个文件其实只是改变了内存中的文件，save以后写回外存
  - 可以**“删除文件”**（点了“删除”之后，图形化交互进程通过操作系统提供的“删除文件”功能，即**delete 系统调用**，将文件数据从外存中删除）
  - 可以**打开文件（open系统调用）**
    - 读/写文件之前，需要“打开文件”。这跟简单的双击是不一样的。
  - 可以**关闭文件（close系统调用）**
    - 读/写文件结束之后，需要“关闭文件”。这个那个简单的×也是不一样的。
- **从上往下看，文件数据应该怎么存放在外存（磁盘）上？**
  - “文件的物理结构”部分会探讨的内容
  - 文件数据放在连续的几个磁盘块中还是离散的磁盘块儿中？
  - 文件数据要是放在离散的几个磁盘块中。此时，应该如何记录各个磁盘块之间的先后顺序呢？
- 其他需要由操作系统实现的文件管理功能
  - 文件共享：使多个用户可以共享使用一个文件
  - 文件保护：如何保证不同的用户对文件有不同的操作权限

## 4.2 文件的逻辑结构（文件内部数据怎么组织）

按文件是否有结构分类，可以分为无结构文件、有结构文件两种。

- 无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如：Windows 操作系统中的.txt 文件。
- 有结构文件：**由一组相似的记录（记录就是表格里的一行）**组成，又称“记录式文件”。每条**记录由若干个数据项组成（数据项就是表格里个一格）**。如：数据库表文件。一般来说，**每条记录有一个数据项可作为关键字（比如每个人的学号不一样，学号可以作为关键字，作为识别不同记录的ID）**（作为识别不同记录的ID）

### 1.无结构文件

文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。

如：Windows 操作系统中的.txt 文件。

### 2.有结构文件——顺序文件

顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。一般默认物理上也是顺序存储，也就是顺序表。（即逻辑上相邻，物理上也相邻，一般不用链表，而是顺序表）

顺序文件的两个存储方式：

- 串结构：记录之间的顺序与关键字无关，通常记录是按存入时间决定的顺序

  - 也就是各行之间没什么顺序，按存入时间排列的，开头学号没有递增递减规律
  - 采用串结构，无法快速找到某关键字对应的记录

- 顺序结构：记录之间按关键字顺序进行排列

  - 也就是各行之间是有序的，按开头学号从小到大排列

  - 可以快速找到关键字对应的记录

    - （指的是定长记录的情况下）
    - 如果是不定长记录，那么也无法做到快速查找，只能一个一个查找

    

顺序文件的缺点是增加/删除一个记录比较困难（顺序结构比较困难，串结构相对简单）

### 3.有结构文件——索引文件

对于可变长记录文件，要找到第i 个记录，必须先顺序第查找前i-1 个记录，但是很多应用场景中又必须使用可变长记录。如何解决这个问题？

建立一张**索引表**以加快文件检索速度。**每条记录对应一个索引项**。

可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。

### 4.有结构文件——索引顺序文件

思考索引文件的缺点：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。

索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并**不是每个记录对应一个索引表项**，而是**一组记录对应一个索引表项**。

减少了索引表的表项。

### 5.总结

![YMOk7T.png](https://s1.ax1x.com/2020/05/09/YMOk7T.png)

## 4.3 文件目录（文件之间怎么组织）

目录本身也是个有结构文件

### 1.文件控制块（就是目录里的每一行）

- **目录**本身**也是**个有结构**文件**。**目录的每一条记录，就是一个文件控制块。**
- 文件控制块最主要的功能是实现了文件名和物理位置的映射，其次**每个文件控制块（也就是目录里的一条记录）**里还包含了存取权限、使用信息等等数据项（这些**数据项就表示了该文件名对应文件的各种属性**）。

![YMxFxJ.png](https://s1.ax1x.com/2020/05/09/YMxFxJ.png)

需要对目录进行哪些操作?

- 搜索:当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项
- 创建文件:创建一 个新文件时，需要在其所属的目录中增加一个目录项
- 删除文件:当删除一个文件时，需要在目录中删除相应的目录项
- 显示目录:用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性
- 修改目录:某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项(如:文件重命名)

### 2.目录结构

例如:自拍.jpg的绝对路径是“/照片 /2015-08/自拍jpg。系统根据绝对路径一层一层地找到下一级目录。刚开始**从外存读入根目录的目录表**;找到“照片”目录的存放位置后，**从外存读入“照片”的目录表**;再找到“2015-08” 目录的存放位置，**再从外存读入“2015-08”的目录表**;最后才找到文件“自拍.jpg”的存放位置，然后把这个j**pg从外存读进来**显示。整个过程需要4次读磁盘I/O操作。

- **树形目录结构：**
  - 树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享（物理内存只有一份文件，但又两个目录指向了它。比如通过软连接）。
- **无环图目录结构**：
  - 注意:共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。
  - 如果共享文件，那么删除时其实只是删除了目录项，其他目录还可以访问那个文件。

### 3.索引结构（对文件控制块的优化）

FCB里存指针，具体内容去指针指向的位置取

## 4.4 文件的物理结构（怎么为一个文件分配block）

就是把文件内容，怎样地放在硬盘里。连续分配block？链接分配block?索引分配block?

## 4.5文件存储空间管理（硬盘空闲block怎么管理。盘块位图）

即硬盘空闲block怎么管理。

![Y1VwSs.png](https://s1.ax1x.com/2020/05/09/Y1VwSs.png)

### 1.空闲表法

![Y8y7VA.png](https://s1.ax1x.com/2020/05/10/Y8y7VA.png)

### 2.空闲链表法

![Y8cLjS.png](https://s1.ax1x.com/2020/05/10/Y8cLjS.png)

### 3.位示图法（盘块位图）

这就是FCB数组（i结点）之前的那个东西。

![Y8gwgf.png](https://s1.ax1x.com/2020/05/10/Y8gwgf.png)

一个位，代表一个盘块，0代表空闲，1代表已分配。

利用二进制的一位来表示磁盘中一个盘块的使用情况，可以规定0为空闲，1为使用。一般用 ![[公式]](https://www.zhihu.com/equation?tex=m%5Ctimes+n) 个位数来构成一个二位的位示图map[m,n]。其中![[公式]](https://www.zhihu.com/equation?tex=m%5Ctimes+n)=磁盘块的总块数。

一般来说，空闲快越多，扫描的时间越短。如果空闲空间在磁盘均匀分布，那么在找到“0”之前需要扫描n/r。

注：n=磁盘上数据块的总数；r=空闲块的总数。

**磁盘与内存数据一致性问题**
由于位图存储在硬盘上，为了提高效率，会将其读到内存中来。如何确保硬盘和内存中的位图的一致性？

**前提条件**
位图必须保存在磁盘上；
在内存和磁盘拷贝有所不同；
不允许block[i]（某一块）在内存中的状态为bit[i]=1而在磁盘中bit[i]=0。

**解决办法分为三步：**
1）在磁盘设置bit[i]=1
2）分配block[i]
3）内存中设置bit[i]=1

只要修改磁盘中的值，此时断电重启后，就不会出现已分配的资源未置1啦~

## 4.6文件的基本操作（open read write close）

### 1.创建文件（create系统调用）

进行Create系统调用时，需要提供的几个主要参数:

1. 所需的外存空间大小(如:一个盘块，即1KB)
2. 文件存放路径(“D:/Demo”)
3. 文件名(这个地方默认为“新建文本文档.txt”) .

操作系统在处理Create系统调用时，主要做了两件事:
1.**在外存中找到文件所需的空间**(结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间)，也就**在位示图中寻找空闲block**
2.根据文件存放路径的信息找到该目录对应的目录文件(此处就是D:/Demo目录)，**在目录中创建该文件对应的目录项**。目录项中包含了文件名、文件在外存中的存放位置等信息。

### 2.删除文件（delete系统调用）

进行Delete系统调用时，需要提供的几个主要参数:
1. 文件存放路径(“D:/Demo”)
2. 文件名(“test.txt” )

操作系统在处理Delete系统调用时，主要做了几件事:

1. 根据文件存放路径找到相应的目录文件，从目录中**找到文件名对应的目录项**。
2. 根据该目录项记录的文件在外存的存放位置、文件大小等信息，**回收文件占用的磁盘块**。(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)
3. 从目录表中**删除文件对应的目录项**。

### 3.打开文件（open系统调用）:找到目标文件的具体block

在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数:

1. 文件存放路径(“D:/Demo”)
2. 文件名(“test.txt” )
3. 要对文件的操作类型(如: r只读;rw读写等)

操作系统在处理open系统调用时，主要做了几件事:
1.根据文件存放路径找到相应的目录文件，从目录中**找到文件名对应的的目录项**，并检查该用户是否有指定的操作权限。
2.**将目录项复制到内存中的“打开文件表”中**。并将对应表目的编号返回给用户。之后**用户使用打开文件表的编号来指明要操作的文件。**

![Y8WN59.png](https://s1.ax1x.com/2020/05/10/Y8WN59.png)

### 4.关闭文件（close系统调用）

![Y8WDKK.png](https://s1.ax1x.com/2020/05/10/Y8WDKK.png)

### 5.读文件（read系统调用）

![Y8WxMV.png](https://s1.ax1x.com/2020/05/10/Y8WxMV.png)

### 6.写文件（write系统调用）

![Y8f9ZF.png](https://s1.ax1x.com/2020/05/10/Y8f9ZF.png)

### 7.总结

![Y8fFi9.png](https://s1.ax1x.com/2020/05/10/Y8fFi9.png)

## 4.7文件共享(硬链接和软链接)

- 硬链接：只有把所有链接到文件的目录都删了，才能把文件删除。
  - 硬链接起来的各个目录项和原始文件是一样的权利
- 软连接（快捷方式）：删了真正的文件，没删快捷方式，那么快捷方式不能用了；删了快捷方式，没删真正的文件，那么文件没有被删。
  - 弱链接出来的快捷方式的权利比原始文件弱多了

即当删除原始文件f1后，硬连接f2不受影响，但是符号连接f1的文件（即快捷方式）无效了。

## 4.8 文件保护

- 口令保护
  - 这个就是原始意义上的密码
- 加密保护
  - 是直接对原始数据进行各种操作，就是存进去的东西是加密后的，直接取出来是读不懂的，需要一套翻译工具来解密
- 访问控制
  - 文件访问权限

![YGQZ1f.png](https://s1.ax1x.com/2020/05/11/YGQZ1f.png)

## 4.9 文件系统的层次结构

![YG3vUH.png](https://s1.ax1x.com/2020/05/11/YG3vUH.png)

![YG8vLT.png](https://s1.ax1x.com/2020/05/11/YG8vLT.png)

## 4.10 磁盘的结构（C、H、S）

C：柱面（移动磁头臂，选磁道或者说柱面）    H：磁头（不用物理移动，选盘面）     S：扇区（旋转，选扇区）

## 4.11 磁盘调度算法（读写操作时的，访问block的顺序问题）

**读写操作时的，访问block的顺序问题（电梯调度算法）**

### 1.一次磁盘读/写操作需要的时间

寻道时间：移动磁头臂（选柱面）  

旋转时间（也叫延迟时间）：旋转磁盘，旋扇区

传输时间：从磁盘读出或向磁盘写入数据所经历的时间

### 2.磁盘调度算法（主要是影响寻道时间）

就是怎么合理安排各种IO请求，为了读取效率，肯定不能来一个我就不顾远近来回移动磁头臂

#### 先来先服务算法（FCFS）

根据进程请求访问磁盘的先后顺序进行调度。

- 优点:公平;如果请求访问的磁道比较集中的话，算法性能还算过的去
- 缺点:如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。

#### 短寻道优先(SSTF)

SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。( 其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)

- 优点:性能较好，平均寻道时间短
- 缺点:可能产生“饥饿”现象.

产生饥饿的原因在于:磁头在一个小区域内来回来去地移动

#### 扫描算法（SCAN）(电梯算法)

SSTF算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，**只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动**。这就是扫描算法(SCAN) 的思想。由于磁头移动的方式很像电梯，因此也叫**电梯算法。**

- 优点:性能较好，平均寻道时间较短，不会产生饥饿现象
- 缺点:
  - ①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。
  - ②SCAN算法对于各个位置磁道的响应频率不平均(如:假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离;而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了)

#### 循环扫描算法（C-SCAN)

就是单向，一轮一轮扫描。

SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而**返回时直接快速移动至起始端而不处理任何请求**。

- 优点:比起SCAN来，对于各个位置磁道的响应频率很平均。
- 缺点:只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了;并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来， 平均寻道时间更长。

### 3.总结

![YGxay8.png](https://s1.ax1x.com/2020/05/11/YGxay8.png)

## 4.12 减少磁盘延迟时间的方法（block编号问题）

讲的是实际硬盘的block号编号问题

## 4.13 磁盘的管理

### 1.磁盘初始化

![YGzcAH.png](https://s1.ax1x.com/2020/05/11/YGzcAH.png)

### 2.引导块

![YGzbNj.png](https://s1.ax1x.com/2020/05/11/YGzbNj.png)

### 3.坏块的管理

![YGzzuT.png](https://s1.ax1x.com/2020/05/11/YGzzuT.png)

### 4.总结

![YJSPUJ.png](https://s1.ax1x.com/2020/05/11/YJSPUJ.png)

# 5.第五章外设

1.