# 数据库for秋招

https://www.cnblogs.com/yocichen/p/11266917.html

## 1.数据库的索引

### 牛客版答案

- 索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。
- 索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。
- 索引其实就是b+树（有的是hash，有的是b树）。

### 网上版答案

https://www.cnblogs.com/aspwebchh/p/6652855.html

#### 为什么要给表加上主键（聚集索引）？

- 我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 
- 一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。
-  一个加了主键的表，其实并不能被称之为「表」。因为如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是「平衡树」（b tree 或者b+tree）结构，换句话说，就是整个表就变成了一个索引。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。
  - ![img](https://images2015.cnblogs.com/blog/303980/201703/303980-20170331183927805-434571358.jpg)

#### 为什么加索引后会使查询变快？

- 因为平衡树（b+树）的查找时间复杂度是 O(log n)。而一条一条记录查过去的复杂度是O(n)。

#### 为什么加索引后会使写入、修改、删除变慢？

- 事物都是有两面的， 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS（数据库管理系统(Database Management System)）必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。

#### 聚集索引（主键）与非聚集索引

- 非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。如下图
  - ![img](https://images2015.cnblogs.com/blog/303980/201703/303980-20170331184008805-68908020.jpg)
- 每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。
- 非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据，如下图
  - ![img](https://images2015.cnblogs.com/blog/303980/201703/303980-20170331184024758-1937607304.jpg)
- 不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。 

#### 什么情况下要同时在两个字段上建索引？（覆盖索引、复合索引、多字段索引，一个意思）

- 然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。 上面的内容已经指出， 当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。

- 普通的非聚集索引（单字段索引，非主键）的例子

  - ```
    先看下面这个SQL语句
    
    //建立索引
    
    create index index_birthday on user_info(birthday); //单字段索引
    
    //查询生日在1991年11月1日出生用户的用户名
    
    select user_name from user_info where birthday = '1991-11-1'
    
    这句SQL语句的执行过程如下
    
    首先，通过非聚集索引index_birthday查找birthday等于1991-11-1的所有记录的主键ID值
    
    然后，通过得到的主键ID值执行聚集索引查找，找到主键ID值对就的真实数据（数据行）存储的位置
    
    最后， 从得到的真实数据中取得user_name字段的值返回， 也就是取得最终的结果
    ```

- 双字段的覆盖索引的例子

  - ```
    //建立索引
    create index index_birthday_and_user_name on user_info(birthday, user_name);  //双字段索引
    
    //这句SQL语句的执行过程就会变为
    通过非聚集索引index_birthday_and_user_name查找birthday等于1991-11-1的叶节点的内容，然而， 叶节点中除了有user_name表主键ID的值以外， user_name字段的值也在里面， 因此不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中user_name的值返回即可。 
    
    通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能。如下图
    ```

  - ![img](https://images2015.cnblogs.com/blog/303980/201703/303980-20170331184049867-1554738501.jpg)

### 索引的分类

- 聚集索引（主键索引）
  - 找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。
  - 主键索引叶子节点的值存储的就是MySQL的数据行
- 非聚集索引（普通索引、辅助索引）
  - 索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。
  - 普通索引的叶子节点的值存储的是主键值。
- 复合索引（覆盖索引、多字段索引）
  - 不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中user_name的值返回即可

### 索引的类型

- hash
- B tree
- R tree
- Full text
  - 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。
- 所有类型的可选项：unique
  - 索引列的值必须唯一（不可以出现相同的值），但允许有空值。如果是组合索引，则列值的组合必须唯一。

### 混合版的索引类型

- 主键索引 PRIMARY KEY：也叫聚集索引
  - 它肯定是唯一索引。
- 唯一索引 UNIQUE：
  - 索引列的值必须唯一（不可以出现相同的值），但允许有空值。如果是组合索引，则列值的组合必须唯一。
- 普通索引 INDEX：
  - 也叫非聚集索引
- 组合索引 INDEX：
  - 也叫覆盖索引、多字段索引
- 全文索引 FULLTEXT：
  - 也称全文检索，是目前搜索引擎使用的一种关键技术。

### 多创建索引一定会好吗

- 在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
- 只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
- 定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
- 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。**当增加索引时，会提高检索性能，但是会降低修改性能**。当减少索引时，会提高修改性能，降低检索性能。因此，**当修改性能远远大于检索性能时，不应该创建索引**。

### 索引的优化（再学学）

https://zhuanlan.zhihu.com/p/61687047

- 1.如果MySQL估计使用索引比全表扫描还慢，则不会使用索引。
  - 返回数据的比例是重要的指标，比例越低越容易命中索引。记住这个范围值——30%，后面所讲的内容都是建立在返回数据的比例在30%以内的基础上。
- 2.前导模糊查询不能命中索引。
- 3.数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来。
- 4.复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引。
- 5.union、in、or都能够命中索引，建议使用in。
- 6.用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。
- 7.负向条件查询不能使用索引，可以优化为in查询。
- 8.范围条件查询可以命中索引。范围条件有：<、<=、>、>=、between等。
- 9.数据库执行计算不会命中索引。
- 10.利用覆盖索引进行查询，避免回表。
- 11.建立索引的列，不允许为null。

## 2.数据库事务

### 事务的概念

- 数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。
- 事务是保证多个SQL操作的一致性，如果一条失败全部SQL也将失效。

### 事务隔离（4个隔离级别）

同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

![image-20210302195430339](http://pichost.yangyadong.site/img/image-20210302195430339.png)

### 事物四个特性（ACID）

- 事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。
- 事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。

- 1.原子性（Atomicity）
  - 事务被视为不可分割的最小单元，事物的所有操作要么成功，要么失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。
  - 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
- 2.一致性（Consistency）
  - 数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。
  - 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个**事务执行之前和执行之后都必须处于一致性状态。**
  - 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
- 3.隔离性（Isolation）
  - 一个事务所做的修改在最终提交以前，对其他事务是可不见的。
  - 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
  - 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
  - 多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。
- 4.持久性（Durability）
  - 一旦事务提交，则其所做的修改将会永远保存到数据库中。不会因为异常、宕机而造成数据错误或丢失。
  - 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
  - 例如我们在使用JDBC（Java数据库连接）操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

### 并发问题（脏读、不可重复读、幻读）

- 1.脏读：
  - 是指一个事务没有提交时，可被其他事务读取到。
  - 事务B读取了事务A更新的数据，然后A事务回滚操作，那么B读取到的数据是脏数据
- 2.不可重复读：
  - 指在事务中多次读取的数据出现不一致的情况，我们希望读取的数据在本事务中是一致的。
  - 事务B多次读取同一数据，事务A在事务B多次读取的过程中，对数据作了更新并提交，导致事务B多次读取同一数据时，结果不一致。
- 3.幻读：
  - 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。
  - 系统管理员B将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员A就在这个时候插入了一条具体分数的记录，当系统管理员B改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
- 备注：
  - 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，而解决幻读需要锁表。
  - 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。

## 3.inner join和left join

- left join(左联接)：返回包括左表中的所有记录和右表中联结字段相等的记录
- right join(右联接)：返回包括右表中的所有记录和左表中联结字段相等的记录 
- inner join(等值连接)： 只返回两个表中联结字段相等的行

## 4.请你介绍一下mysql的MVCC机制

- MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。
- 是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读（read-committed）和可重复读（repeatable-read）这两种隔离级别。
- MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。
  - MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。

## 5.请你说一下MySQL引擎和区别

#### 1.MySQL引擎

- MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。
- 数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。
- MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。

#### 2.InnoDB和Mylsam的区别：

- 1.事务：
  - InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
- 2.行数保存：
  - InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行。而MyISAM用一个变量保存了整个表的行数，MyISAM只要简单的读出该变量即可，速度很快。注意的是，当count()语句包含where条件时，两种表的操作是一样的。
- 3.索引存储：
  - Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；（备注：新版mysql 5.6开始的Innodb已经支持全文索引了）
  - MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。
  - InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
- 4.外键：
  - InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；
- 5.主键：
  - MyISAM：允许没有主键的表存在。
  - InnoDB：如果没有设定主键，就会自动生成一个 6 字节的主键(用户不可见)。
- 5.锁的粒度：
  - MyISAM只支持表锁。InnoDB支持表锁和行锁。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

## 6.二叉树、B tree和B+tree的区别

### 1.InnoDB的一棵B+树可以存放多少行数据？

答案：**约2千万**

### 2.为什么不用二叉树

- 其实从算法逻辑上来讲，二叉查找树的查找速度和比较次数都是最小的。但是，我们不得不考虑一个现实问题:磁盘I0。
- 数据库索引是存储在磁盘上的，当数据量比较大的时候,索引的大小可能有几个G甚至更多。
- 当我们利用索引查询的时候，能把整个索引全部加载到内存吗？显然不可能。能做的只有逐一加载每一个磁盘页，这里的磁盘页对应着索引树的节点。
- 磁盘的IO次数由什么决定？
  - 索引树的高度。
  - 没错，既然如此，为了减少磁盘IO次数，我们就需要把原本“瘦高”的树结构变得“矮胖”。这就是B-树的特征之一。

### 3.平衡二叉树

- 平衡二叉树能保证数据的左右两边的节点层级相差不会大于1，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找；
- 平衡二叉树特点：
  - （1）非叶子节点最多拥有两个子节点；
  - （2）非叶子节值大于左边子节点、小于右边子节点；
  - （3）树的左右两边的层级数相差不会大于1;
  - （4）没有值相等重复的节点;

### 4.B树（Balance Tree）

- B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）
- B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;

### 5.B+树

- 在B树中，每一个元素在该树中只出现一次，可能在分支结点，也可能在叶子节点。
  - 而在B+树中，出现在分支节点上的元素，一定会在叶子节点上再次出现。
- B+跟B树不同。B+树的**非叶子**节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加；
  - 所以B+树的层级可以更少，B+树的非叶子节点仅仅是索引的作用，非叶子节点上不再存储关键字记录的指针（也就是只存key，不存value）。
- 每一个叶子结点都会保存一个指向后一个叶子节点的指针。
  - 即B+树底部的叶子结点是链表形式

- **B树**相对于**B+树**的优点：
  - **B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。
- B+相对B树的优点：
  - 1.B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；
    - B+跟B树不同B+树的**非叶子**节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加，层级就可以减少；
    - B+树改进了B树, 让内结点只作索引使用, 去掉了其中指向data record的指针, 使得每个结点中能够存放更多的key, 因此能有更大的出度. 这有什么用? 这样就意味着存放同样多的key, 树的层高能进一步被压缩, 使得检索的时间更短. 
  - 2.B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
  - 3.B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
    - 由于B+底部的叶子结点是链表形式, 因此也可以实现更方便的顺序遍历
  - 4.B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
    - 由于B+底部的叶子结点是链表形式, 因此也可以实现更方便的顺序遍历

## 7.数据库的三大范式



