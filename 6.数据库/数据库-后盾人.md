# 数据库-后盾人

- select * from stu;
  - *：查询stu表的所有表项（行）的所有列
- select  class_id from stu;
  - class_id ：只查询stu表的所有表项（行）的class_id列

## 1.简单命令-数据库

- 创建数据库

  - ```
    mysql> create database shop charset utf8;
    //charset utf8是选定编码方式
    ```

- 查看创建的数据库

  - ```
    mysql> show databases;
    +--------------------+
    | Database           |
    +--------------------+
    | information_schema |
    | mysql              |
    | performance_schema |
    | shop               |  //这是刚才创建的shop数据库
    | sys                |
    | yourdb             |
    +--------------------+
    6 rows in set (0.00 sec)
    
    mysql>
    ```

- 使用某个数据库

  - ```
    mysql> use shop;
    Database changed
    mysql>
    ```

- 删除某个数据库

  - ```
    mysql> drop database shop;
    Query OK, 0 rows affected (0.01 sec)
    mysql>
    ```

  - 或者加个判断

    - ```
      mysql> drop database if exists shop;
      ```

- 查看创建的数据库的结构

  - ```
    mysql> show create database shop;
    +----------+---------------------------------------------------------------+
    | Database | Create Database                                               |
    +----------+---------------------------------------------------------------+
    | shop     | CREATE DATABASE `shop` /*!40100 DEFAULT CHARACTER SET utf8 */ |
    +----------+---------------------------------------------------------------+
    1 row in set (0.00 sec)
    
    mysql>
    ```

## 2.简单命令-表

- 创建一个表

  - ```
    CREATE TABLE class(id int primary key auto_increment,cname varchar(30) not null,description varchar(100) null) charset utf8;
    ```

  - 字段 id ：为主键自增

    - primary key是主键，让我们的id值有个索引。这样的话我们查找id=1，id=2的时候速度会比较快。
    - auto_increment是自增，主键不用我们手动维护，它会自动增加。

  - 字段 cname 为字符串类型varchar 并不允许为 null

  - 字段 description 为可为null 字符串

  - 字符集为 utf8 ，如果不设置将继承数据库字符集

- 查看表

  - ```
    mysql> desc class;
    +-------------+--------------+------+-----+---------+----------------+
    | Field       | Type         | Null | Key | Default | Extra          |
    +-------------+--------------+------+-----+---------+----------------+
    | id          | int(11)      | NO   | PRI | NULL    | auto_increment |
    | cname       | varchar(30)  | NO   |     | NULL    |                |
    | description | varchar(100) | YES  |     | NULL    |                |
    +-------------+--------------+------+-----+---------+----------------+
    3 rows in set (0.00 sec)
    
    mysql>
    ```

- 向表里添加测试数据

  - 方法1

    - ```
      INSERT into class set cname ='PHP',description ='学习 PHP 开发网站';
      ```

  - 方法2

    - ```
      INSERT into class (cname,description) values('linux','服务器知识'),('mysql','数据库学习'),('C++',null);
      ```

- 查看表数据

  - ```
    select * from class;
    ```

  - ![image-20210228150153425](http://pichost.yangyadong.site/img/image-20210228150153425.png)

## 3.已经有一个表了，从一个表快速构建另一个表

- ```
  CREATE table test like class;//根据已经存在的表结构创建新表
  insert into test select * from class;//复制class表的所有数据到test表中
  insert into test (cname) select cname from class;//只复制批定字段
  
  CREATE table a select * from class;//创建表时同时复制数据
  
  CREATE table b (id int primary key auto_increment,cname varchar(30)) select cname FROM class;//只复制指定字段
  
  CREATE table c (id int primary key auto_increment,name varchar(30)) select cname as name FROM class;//只复制指定字段，并起别名
  ```

## 4.查询基本操作

- 从class表中，查询所有字段

  - ```
    SELECT * from class;
    ```

  - ![image-20210228153331459](http://pichost.yangyadong.site/img/image-20210228153331459.png)

- 从class表中，查询特定字段

  - ```
    SELECT cname,id FROM class;
    ```

  - ![image-20210228153519806](http://pichost.yangyadong.site/img/image-20210228153519806.png)

- 从class表中，查询特定字段，并为该字段起别名

  - ```
    SELECT cname,id as iddd FROM class;
    ```

  - ![image-20210228153721734](http://pichost.yangyadong.site/img/image-20210228153721734.png)

- 根据条件的查询

  - ```
    SELECT * FROM class where id>2;//筛选出id>2的
    ```

    - ![image-20210228154018543](http://pichost.yangyadong.site/img/image-20210228154018543.png)

  - ```
    SELECT * FROM class where cname='PHP';//筛选出cname是php的
    ```

    - ![image-20210228154136590](http://pichost.yangyadong.site/img/image-20210228154136590.png)

  - ```
    SELECT * from class where description like '%学习%'; //查找出description字段中包含学习字段的数据
    ```

    - ![image-20210228154456223](http://pichost.yangyadong.site/img/image-20210228154456223.png)

  - ```
    SELECT * from class where description like '%学习%' and id>2; //查找出description字段中包含学习字段的，并且id>2的数据
    ```

    - ![image-20210228154543087](http://pichost.yangyadong.site/img/image-20210228154543087.png)

  - ```
    SELECT * from class where description not like '%学习%' and id>2;////查找出description字段中不包含学习字段的，并且id>2的数据
    ```

    - ![image-20210228154713550](http://pichost.yangyadong.site/img/image-20210228154713550.png)

- 使用连接函数的查询

  - ```
    SELECT CONCAT(cname,description) as class_info FROM class;
    ```

  - ![image-20210228154939326](http://pichost.yangyadong.site/img/image-20210228154939326.png)

## 5.查询进阶（DISTINCT、BETWEEN、like等）

- 关键字
  - distinct：去掉重复的
  - BETWEEN a and b：a到b之间
  - in (2,3)：2到3之间[2,3]
  - and、or
  - like：包含..

- 已知stu表

  - ![image-20210228164748558](http://pichost.yangyadong.site/img/image-20210228164748558.png)

- 查询所有的class_id

  - ```
    SELECT class_id from stu;
    ```

  - ![image-20210228164948740](http://pichost.yangyadong.site/img/image-20210228164948740.png)

  - 有重复项

- 查询所有的class_id，**去掉重复项**

  - ```
    SELECT DISTINCT class_id FROM stu;
    ```

  - ![image-20210228165046380](http://pichost.yangyadong.site/img/image-20210228165046380.png)

- 查询20~40岁之间的同学

  - ```
    SELECT * FROM stu where age >=20 and age <=40;
    ```

  - 或者是

  - ```
    SELECT * FROM stu where age BETWEEN 20 and 40;
    ```

- 查询不在20~40岁之间的同学

  - ```
    SELECT * FROM stu where age not BETWEEN 20 and 40;
    ```

- 查询在2班到3班的同学

  - ```
    SELECT * FROM stu where class_id =2 or class_id =3;
    ```

  - 或者是

  - ```
    SELECT * FROM stu where class_id in (2,3);
    ```

## 6.mysql对null值的处理技巧

- 已知stu表

  - ![image-20210228164748558](http://pichost.yangyadong.site/img/image-20210228164748558.png)

- 比如你想查询class_id为null的那些数据

  - ```
    mysql> select * from stu where class_id=null;
    Empty set (0.00 sec)
    
    mysql>
    ```

  - 查询失败。

- 正确写法

  - ```
    select * from stu where class_id is null;
    ```

  - ![image-20210228171339872](http://pichost.yangyadong.site/img/image-20210228171339872.png)

- ifnull函数

  - 如果class_id有值的话，就让它显示那个值。如果没值，就让它显示未分配。

  - ```
    SELECT sname ,if(class_id,class_id,'未分配') FROM stu;
    或者
    SELECT sname,IFNULL(class_id,'未分配') FROM stu;
    ```

  - ![image-20210228171740665](http://pichost.yangyadong.site/img/image-20210228171740665.png)

## 7.排序与数据区间筛选处理技巧

- order by age desc；按照年龄从大到小排序（desc降序）

  - ![image-20210228172014660](http://pichost.yangyadong.site/img/image-20210228172014660.png)

- order by class_id asc；按照班级从小到大排序(asc升序)

  - ![image-20210228172246439](http://pichost.yangyadong.site/img/image-20210228172246439.png)

- 按照班级从小到大排序，同班同学按年龄从小到大升序

  - ![image-20210228172408652](http://pichost.yangyadong.site/img/image-20210228172408652.png)

- 取数据库里最后一个填进去的同学的记录（使用limit关键字）

  - ```
    mysql> select * from stu order by id desc limit 1;
    按照id降序排列，只取1个数据
    ```

  - ![image-20210228172619909](http://pichost.yangyadong.site/img/image-20210228172619909.png)

- limit 0,2和limit 1,2

  - ![image-20210228172919236](http://pichost.yangyadong.site/img/image-20210228172919236.png)

# 简洁

- SQL语句
- 对于单条记录的操作
  - 查询：SELECT
  - 操纵：INSERT（插入记录）、UPDATA（更改记录）、DELETE（删除记录）
- 对于表的操作
  - CREATE（创建表）、DROP（删除表）、ALTER（更改表的属性、更改字段的属性、添加字段）

- 数据库、表、字段（列）
- shop    stu   cname
- 一行就是一条记录。

# 多表

- 1对1：主表和从表
  - 常使用的信息放在主表，不常使用的信息放在从表
- 1对多：
  - 多的一方记录少的。
  - 学生记录班级
- 多对多：
  - 找个中间表。
  - 哪个学生学了哪个课程

## 1.笛卡尔积

多个表的连接将会得到所有可能出现的行，即没有明确做两个表间的关联条件时，所有记录都将符合。

```
SELECT * FROM stu ,class;
```

下面是添加条件后的结果

```
SELECT * FROM stu,class where stu.class_id =class.id ;

SELECT * FROM stu as s,class as c where s.class_id =c.id ;

SELECT s.sname ,c.cname FROM stu as s,class as c where s.class_id =c.id ;
```

## 2.INNER

INNER：所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。

使用`INNER JOIN` 使用多表关联的语义更清晰

```
SELECT * FROM stu as s,class as c where s.class_id =c.id ;
与下边这句，完全等价
SELECT * FROM stu as s inner join class as c ON s.class_id =c.id ;
```
# 事务

## 1.事务隔离等级（依次递增）

- 读未提交
  - A事务里改变了信息，未commit，B事务都可以看到改变。
- 不可重复读
  - A事务里改变了信息，commit后，B事务就可以看到改变。
  - 即B事务有可能第一次读，和第二次读读到的内容不一样。即不可重复读，一旦重复读则可能两次读取结果不一致。
- 可重复读
  - 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。
- 串行化
  - A事务在执行时，B事务的所有命令将卡住不执行。
  - 在事务A没有提交时，事务B是不能插入数据的（表现形式为等待）。
  - 这在高并发时显然不合适。

## 2.并发问题

- 脏读：
  - 事务B读取了事务A更新的数据，然后A事务回滚操作，那么B读取到的数据是脏数据
- 不可重复读：
  - 事务B多次读取同一数据，事务A在事务B多次读取的过程中，对数据作了更新并提交，导致事务B多次读取同一数据时，结果不一致。
  - 不可重复读指在事务中多次读取的数据出现不一致的情况，我们希望读取的数据在本事务中是一致的。
- 幻读：
  - 系统管理员B将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员A就在这个时候插入了一条具体分数的记录，当系统管理员B改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
- 备注：
  - 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，而解决幻读需要锁表。
  - 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。

## 3.联系

![image-20210302094704815](http://pichost.yangyadong.site/img/image-20210302094704815.png)

# 锁

## 1.在事务处理中

- 对于有索引的字段，是行锁
- 对于没有索引的字段，是表锁

能锁的范围越小越好，这样就不会影响到其他用户操作使用。

## 非索引阻塞

使用非索引字段筛选时，将造成全表锁定即表级锁，应该避免这种情况发生，提升数据库的并发性能。

## 2.悲观锁（行锁）

- 悲观锁指对数据被外界修改持保守态度，**在整个数据处理过程中，将数据处于锁定状态**，可以很好地解决并发事务的更新丢失问题。

- 下面演示商城下单情况，要用户购买商品后我们要减少库存，如果在高并发情况下多个用户同时修改库存表，会造成库存数据异常，使用悲观锁可以解决这个问题。

- 1.事务A执行悲观锁操作后，其他事务执行同一代码时将阻塞

  - ```
    BEGIN;
    SELECT * FROM goods WHERE id=1 FOR UPDATE;
    UPDATE goods SET num=num-2 WHERE id=1; 
    ...
    ```

  - 注意：FOR UPDATA就上悲观锁了

- 2.事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务

  - ```
    BEGIN;
    ## B事务中查询中也要使用 FOR UPDATE 悲观锁
    SELECT * FROM goods WHERE id=1 FOR UPDATE;
    -- 阻塞中...
    ```

- 3.事务A提交后，事务B会得到事务A操作后的结果

  - ```
    ...
    COMMIT;
    ...
    ```

## 3.乐观锁（行锁）

- 在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是**在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。**

- 下面使用版本字段来实现乐观锁操作，并实现更改商品库存的案例。

- 1.事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）

  - ```
    BEGIN;
    SELECT * FROM goods WHERE id = 1;
    ```

  - 注意，这里没有FOR UPDATA，没上悲观锁

- 2.事务B同时查询，也获取了版本号为0的记录

  - ```
    BEGIN;
    SELECT * FROM goods WHERE id = 1;
    ```

- 3.事务A更改库存，并增加版本号

  - ```
    UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;
    ```

  - 版本会修改

- 4.事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。

  - ```
    UPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;
    ```

  - 版本号变了，不是0了，说明已经有人动过这数据了。那这条语句就不会修改数据。

- 悲观锁：

  - 一开始就觉得会肯定会有人跟我同一时间处理同一数据。我处理的时候一上来就给它锁住，不让别人处理。

- 乐观锁：

  - 我觉得不会有人跟我同一时间处理同一数据。我直接处理，并不上锁。只在最后提交时检查一下，有没有人动过这个数据，要是有人动过，那我这次的处理就作废了。要是没有别人比我先处理，那我就处理成功了。

## 4.表锁机制（读写锁）

针对一些不支持事务的处理引擎可以使用锁表的方式控制业务。

### 读锁（表锁）

- 为表设置读锁后，当前会话和其他会话都不可以修改数据，但可以读取表数据。

  - 谁都只能读，我自己会话也只能读。

- 1.会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表。

  - ```
    LOCK TABLE goods READ;
    UPDATE goods SET num=300 WHERE id=1;//失败
    SELECT * FROM stu;
    ```

- 2.因为会话A对表`goods`设置了读锁，所以会话B也不能修改

  - ```
    update goods set num=200 where id=1;
    -- 阻塞
    ```

- 3.会话A解锁表后，其他会话又可以继续操作表了

  - ```
    UNLOCK TABLES;
    ```

### 写锁（表锁）

- 为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。

- 1.会话A对表goods和stu设置写锁，本会话可以正常操作表， 并不能操作其他表

  - ```
    LOCK TABLE goods WRITE，stu WRITE;
    INSERT INTO goods (name,num )VALUES('后盾人教程',300);
    ```

- 2.会话B读取/写入表数据都将阻塞

  - ```
    select * from goods
    ```

- 3.会话A解锁表数据后，其他会话都可以正常操作了

  - ```
    UNLOCK TABLES;
    ```

## 5.总结

- 能用行锁，就不用表锁
- 越能并发越好

# 外键约束（外键关联）

## 1.外键约束

- 一张表发生变化，影响另一张表。不需要程序控制，mysql自动控制。
- 主表的数据的变动，会影响到子表。
- 比如学生和班级表，学生表完全依赖班级表，我们可以通过外键约束让学生表与班级表产生关联，当班级表数据变化时影响学生表，下面大叔带你详细掌握外键约束。
  - 父表和子表储存引擎要一致
  - 使用InnoDB引擎支持外键约束
  - 外键要与主表列（主表关联键）类型一致
  - 外键列使用索引（有些版本的mysql会自动帮助为外键设置索引)
- 哪个表里声明外键，哪个表就是子表
- 主表发生变化的时候，影响子表。

## 2.外键动作（影响方式）

- cascade：